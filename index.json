[{"content":"I made this article to overview different approaches to make wrappers in Scala. Wrapper pattern is useful to add additional logic to methods of a class: logging, metering, tracing, timeouts, retries. Scala is a great language and provides many ways to create wrappers. I decided to create this article because it seems that there\u0026rsquo;s no consensus between Scala developers on how to write them and no clear understanding of downsides and limitations.\nI\u0026rsquo;m going to review the following ways: trait mixin, class wrapper, and tofu mid.\nLet\u0026rsquo;s introduce a simple trait to start with: trait ItemDao { def upsert(item: Item): Unit def get(id: Id): Option[Item] }\nOne of the possible ways to create a wrapper is trait mixin technique. We just need to make a trait that calls parent implementation of a method, and write our code.\ntrait LoggedItemDaoWrapper extends ItemDao with StrictLogging { abstract override def upsert(item: Item): Unit = { logger.info(s\u0026#34;upsert($item) is called\u0026#34;) super.upsert(item) logger.info(s\u0026#34;upsert($item) = ()\u0026#34;) } abstract override def get(id: Id): Option[Item] = { logger.info(s\u0026#34;get($id) is called\u0026#34;) val result = super.get(id) logger.info(s\u0026#34;get($id) = $result\u0026#34;) } } To make it work all we need to do is to connect it to our implementation: new ItemDaoImpl(...) extends LoggedItemDaoWrapper\nSo far it looks nice and seems easy to understand. Unfortunately, things become messy if there are dependencies to provide.\nLet\u0026rsquo;s make our trait to have asynchronous interface: trait ItemDao { def upsert(item: Item): Future[Unit] def get(id: Id): Future[Option[Item]] }\nIf we have an interface that returns scala.concurrent.Future, then we have to provide ExecutionContext to our wrappers to be able to call map, flatMap, and other methods. Many developers create global single thread execution context to keep things simple, but let\u0026rsquo;s pretend I didn\u0026rsquo;t say that.\ntrait LoggedItemDaoWrapper extends ItemDao with StrictLogging { protected implicit def ec: ExecutionContext abstract override def upsert(item: Item): Unit = { super.upsert(item).map(_ =\u0026gt; logger.info(s\u0026#34;upsert($item) = ()\u0026#34;)) } abstract override def get(id: Id): Option[Item] = { super.get(id).map(result =\u0026gt; logger.info(s\u0026#34;get($id) = $result\u0026#34;)) } } val itemDao: ItemDao = new ItemDaoImpl(...) extends LoggedItemDaoWrapper { override def ec = yourEc } The initialization code is not as clear as before since we provide ExecutionContext through override mechanism, and now we need to keep in mind initialization order because it\u0026rsquo;s easy to get NullPointerException there. Initialization gets uglier if we have many wrappers for a class with different dependencies.\nIt can become even worse if we have Tagless Final. When we write wrappers with TF we have to keep granularity of type classes, but when it comes to initialization, we\u0026rsquo;re doomed because different wrappers require different type class instances to be provided as function definitions. Since we can\u0026rsquo;t ask for a type class via context bounds we have to use the same mechanism as shown before.\nHere\u0026rsquo;s an example how TF code might look like:\ntrait ItemDao[F[_]] { def upsert(item: Item): F[Unit] def get(id: Id): F[Option[Item]] } trait LoggedItemDaoWrapper[F[_]] extends ItemDao[F] with StrictLogging { implicit protected def mt: MonadThrow[F] abstract override def upsert(item: Item): F[Unit] = { super.upsert(item).attemptTap(...) } abstract override def get(id: Id): F[Option[Item]] = { super.get(id).attemptTap(...) } } val itemDao: ItemDao[F] = new ItemDaoImpl[F](...) extends LoggedItemDaoWrapper[F] with MeteredItemDaoWrapper[F] with TimeoutItemDaoWrapper[F] { override def mt: MonadThrow[F] = async override def at: ApplicativeError[F] = async override def concurrent: Concurrent[F] = async override def timer: Timer[F] = _timer override def gauge: Gauge = methodCallGauge } In order to reduce the amount of boilerplate and to make sure function names are the same everywhere, we\u0026rsquo;d want to implement type class providers.\ntrait MonadThrowSupport[F[_]] extends ApplicativeThrowSupport[F] { implicit protected def mt: MonadThrow[F] override implicit protected def at: ApplicativeError[F] = mt } trait LoggingSupport[F[_]] extends MonadThrowSupport[F] with StrictLogging trait LoggedItemDaoWrapper[F[_]] extends ItemDao[F] with LoggingSupport[F] { abstract override def upsert(item: Item): F[Unit] = { super.upsert(item).attemptTap(...) } abstract override def get(id: Id): F[Option[Item]] = { super.get(id).attemptTap(...) } } And then we\u0026rsquo;d want to make a super-provider for everything to reduce boilerplate in initialization code.\ntrait SuperProvider[F[_]] extends MonadThrowSupport[F] with ConcurrentSupport[F] with TimerSupport[F] with ClockSupport[F] with PrometheusGaugeSupport { override def mt: MonadThrow[F] = async override def concurrent: Concurrent[F] = async override def timer: Timer[F] = _timer override def clock: Clock[F] = _clock override def gauge: Gauge = methodCallGauge } val itemDao: ItemDao[F] = new ItemDaoImpl[F](...) extends LoggedItemDaoWrapper[F] with MeteredItemDaoWrapper[F] with TimeoutItemDaoWrapper[F] with SuperProvider[F] We managed to hide all the ugly stuff behind SuperProvider trait and support traits, but it\u0026rsquo;s hard to reason about provided dependencies and their initialization. Initialization of components themselves looks clean but there\u0026rsquo;s a strong feeling that Tagless Final went wrong and code shouldn\u0026rsquo;t be written this way.\n","permalink":"http://awethon.github.io/posts/scala-wrappers/","summary":"I made this article to overview different approaches to make wrappers in Scala. Wrapper pattern is useful to add additional logic to methods of a class: logging, metering, tracing, timeouts, retries. Scala is a great language and provides many ways to create wrappers. I decided to create this article because it seems that there\u0026rsquo;s no consensus between Scala developers on how to write them and no clear understanding of downsides and limitations.","title":"Different ways to make wrappers in Scala 2.x"}]