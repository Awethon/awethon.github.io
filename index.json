[{"content":"I made this article to overview different approaches to make AOP in Scala and to show downsides and limitations they have. These approaches are: trait mixin, class wrapper, and tofu mid.\nLet\u0026rsquo;s imagine that we have the trait that defines an interface of dao: trait ItemDao { def upsert(item: Item): Unit def get(id: Id): Option[Item] }\nOne of the possible ways to do AOP is trait mixins. We just make a trait that calls parent implementation of a method, and then we write our code before and after it.\ntrait LoggedItemDaoAspect extends ItemDao with StrictLogging { abstract override def upsert(item: Item): Unit = { logger.info(s\u0026#34;upsert($item) is called\u0026#34;) super.upsert(item) logger.info(s\u0026#34;upsert($item) = ()\u0026#34;) } abstract override def get(id: Id): Option[Item] = { logger.info(s\u0026#34;get($id) is called\u0026#34;) val result = super.get(id) logger.info(s\u0026#34;get($id) = $result\u0026#34;) } } All we need to do is to connect it to our implementation: new ItemDaoImpl(...) extends LoggedItemDaoAspect\nThings become messy if there are dependencies to provide. Whenever we have an interface that returns scala.concurrent.Future we need to provide ExecutionContext in our aspects to be able to call map, flatMap, and other methods.\ntrait ItemDao { def upsert(item: Item): Future[Unit] def get(id: Id): Future[Option[Item]] } trait LoggedItemDaoAspect extends ItemDao with StrictLogging { protected implicit def ec: ExecutionContext abstract override def upsert(item: Item): Unit = { super.upsert(item).map(_ =\u0026gt; logger.info(s\u0026#34;upsert($item) = ()\u0026#34;)) } abstract override def get(id: Id): Option[Item] = { super.get(id).map(result =\u0026gt; logger.info(s\u0026#34;get($id) = $result\u0026#34;)) } } val itemDao: ItemDao = new ItemDaoImpl(...) extends LoggedItemDaoAspect { override def ec = yourEc } The initialization code is not as clear as before since we provide ExecutionContext through override mechanism, and now we need to keep in mind initialization order because it\u0026rsquo;s easy to get NullPointerException there.\nIf we have Tagless Final in a code then we\u0026rsquo;re doomed because different aspects will require different typeclass instances to be provided as function definitions. Since we can\u0026rsquo;t ask for a typeclass via context bounds we have to use the same mechanism as shown before.\nHere\u0026rsquo;s an example how TF code might look like:\ntrait LoggedItemDaoAspect[F[_]] extends ItemDao[F] with StrictLogging { implicit protected def mt: MonadThrow[F] abstract override def upsert(item: Item): F[Unit] = { super.upsert(item).attemptTap(...) } abstract override def get(id: Id): F[Option[Item]] = { super.get(id).attemptTap(...) } } val itemDao: ItemDao[F] = new ItemDaoImpl[F](...) extends LoggedItemDaoAspect[F] with MeteredItemDaoAspect[F] with TimeoutItemDaoAspect[F] { override def mt: MonadThrow[F] = async override def at: ApplicativeError[F] = async override def concurrent: Concurrent[F] = async override def timer: Timer[F] = _timer override def gauge: Gauge = methodCallGauge } In order to reduce the amount of boilerplate and to make sure function names are the same everywhere, we\u0026rsquo;d want to implement typeclass providers.\ntrait MonadThrowSupport[F[_]] extends ApplicativeThrowSupport[F] { implicit protected def mt: MonadThrow[F] override implicit protected def at: ApplicativeError[F] = mt } trait LoggingSupport[F[_]] extends MonadThrowSupport[F] with StrictLogging trait LoggedItemDaoAspect[F[_]] extends ItemDao[F] with LoggingSupport[F] { abstract override def upsert(item: Item): F[Unit] = { super.upsert(item).attemptTap(...) } abstract override def get(id: Id): F[Option[Item]] = { super.get(id).attemptTap(...) } } And then we\u0026rsquo;d want to make a super-provider for everything to reduce boilerplate in initialization code.\ntrait SuperProvider[F[_]] extends MonadThrowSupport[F] with ConcurrentSupport[F] with TimerSupport[F] with ClockSupport[F] with PrometheusGaugeSupport { override def mt: MonadThrow[F] = async override def concurrent: Concurrent[F] = async override def timer: Timer[F] = _timer override def clock: Clock[F] = _clock override def gauge: Gauge = methodCallGauge } val itemDao: ItemDao[F] = new ItemDaoImpl[F](...) extends LoggedItemDaoAspect[F] with MeteredItemDaoAspect[F] with TimeoutItemDaoAspect[F] with SuperProvider[F] As you can see every step we do with traits and Tagless Final the code only gets more and more complex. Even though ItemDao initialization doesn\u0026rsquo;t take many lines of code now and looks clean, it\u0026rsquo;s hard to reason about provided dependencies and their initialization.\n","permalink":"http://awethon.github.io/posts/scala-aop/","summary":"I made this article to overview different approaches to make AOP in Scala and to show downsides and limitations they have. These approaches are: trait mixin, class wrapper, and tofu mid.\nLet\u0026rsquo;s imagine that we have the trait that defines an interface of dao: trait ItemDao { def upsert(item: Item): Unit def get(id: Id): Option[Item] }\nOne of the possible ways to do AOP is trait mixins. We just make a trait that calls parent implementation of a method, and then we write our code before and after it.","title":"Different ways to make AOP in Scala 2.x"}]