<!doctype html><html lang=en dir=auto>
<head>
<link rel="shortcut icon" type=image/x-icon href=favicon.ico><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Different ways to make wrappers in Scala 2.x | Awethon's Page</title>
<meta name=keywords content="scala">
<meta name=description content="This article is made to overview different approaches to make wrappers in Scala.\n Wrapper pattern is useful when you need add additional logic to methods of a class: logging, metering, tracing, timeouts, retries. It helps to keep code clean and focused on business logic. Scala is a great language and provides many ways to create wrappers. Maybe even too many.\n I decided to create this article because it seems that there&rsquo;s no consensus between Scala developers on how to write them and no clear understanding of downsides and limitations.">
<meta name=author content>
<link rel=canonical href=http://awethon.github.io/posts/scala-wrappers/>
<link href=/assets/css/stylesheet.min.d08f6c302eba3eaecd589684c093cecdfe7dfb8745a207401bd0583d3bb31837.css integrity="sha256-0I9sMC66Pq7NWJaEwJPOzf59+4dFogdAG9BYPTuzGDc=" rel="preload stylesheet" as=style>
<link rel=icon href=http://awethon.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=http://awethon.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=http://awethon.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=http://awethon.github.io/apple-touch-icon.png>
<link rel=mask-icon href=http://awethon.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.2">
<meta property="og:title" content="Different ways to make wrappers in Scala 2.x">
<meta property="og:description" content="This article is made to overview different approaches to make wrappers in Scala.\n Wrapper pattern is useful when you need add additional logic to methods of a class: logging, metering, tracing, timeouts, retries. It helps to keep code clean and focused on business logic. Scala is a great language and provides many ways to create wrappers. Maybe even too many.\n I decided to create this article because it seems that there&rsquo;s no consensus between Scala developers on how to write them and no clear understanding of downsides and limitations.">
<meta property="og:type" content="article">
<meta property="og:url" content="http://awethon.github.io/posts/scala-wrappers/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-02-20T21:55:20+03:00">
<meta property="article:modified_time" content="2022-02-20T21:55:20+03:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Different ways to make wrappers in Scala 2.x">
<meta name=twitter:description content="This article is made to overview different approaches to make wrappers in Scala.\n Wrapper pattern is useful when you need add additional logic to methods of a class: logging, metering, tracing, timeouts, retries. It helps to keep code clean and focused on business logic. Scala is a great language and provides many ways to create wrappers. Maybe even too many.\n I decided to create this article because it seems that there&rsquo;s no consensus between Scala developers on how to write them and no clear understanding of downsides and limitations.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://awethon.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Different ways to make wrappers in Scala 2.x","item":"http://awethon.github.io/posts/scala-wrappers/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Different ways to make wrappers in Scala 2.x","name":"Different ways to make wrappers in Scala 2.x","description":"This article is made to overview different approaches to make wrappers in Scala.\\n Wrapper pattern is useful when you need add additional logic to methods of a class: logging, metering, tracing, timeouts, retries. It helps to keep code clean and focused on business logic. Scala is a great language and provides many ways to create wrappers. Maybe even too many.\\n I decided to create this article because it seems that there\u0026rsquo;s no consensus between Scala developers on how to write them and no clear understanding of downsides and limitations.","keywords":["scala"],"articleBody":"This article is made to overview different approaches to make wrappers in Scala.\\n Wrapper pattern is useful when you need add additional logic to methods of a class: logging, metering, tracing, timeouts, retries. It helps to keep code clean and focused on business logic. Scala is a great language and provides many ways to create wrappers. Maybe even too many.\\n I decided to create this article because it seems that there’s no consensus between Scala developers on how to write them and no clear understanding of downsides and limitations.\nI’m going to review the following ways: trait mixin, class wrapper, and tofu mid.\nLet’s introduce a simple trait to start with: trait ItemDao { def upsert(item: Item): Unit def get(id: Id): Option[Item] }\nOne of the possible ways to create a wrapper is trait mixin technique.\\n We just need to make a trait that calls parent implementation of a method, and write our code.\ntrait LoggedItemDaoWrapper extends ItemDao with StrictLogging { abstract override def upsert(item: Item): Unit = { logger.info(s\"upsert($item) is called\") super.upsert(item) logger.info(s\"upsert($item) = ()\") } abstract override def get(id: Id): Option[Item] = { logger.info(s\"get($id) is called\") val result = super.get(id) logger.info(s\"get($id) = $result\") } } To make it work all we need to do is to connect it to our implementation: new ItemDaoImpl(...) extends LoggedItemDaoWrapper\nSo far it looks nice and seems easy to understand.\\n Unfortunately, things become messy if there are dependencies to provide.\nLet’s make our trait to have asynchronous interface: trait ItemDao { def upsert(item: Item): Future[Unit] def get(id: Id): Future[Option[Item]] }\nIf we have an interface that returns scala.concurrent.Future, then we have to provide ExecutionContext to our wrappers to be able to call map, flatMap, and other methods.\\n Many developers create global single thread execution context to keep things simple, but let’s pretend I didn’t say that.\ntrait LoggedItemDaoWrapper extends ItemDao with StrictLogging { protected implicit def ec: ExecutionContext abstract override def upsert(item: Item): Unit = { super.upsert(item).map(_ = logger.info(s\"upsert($item) = ()\")) } abstract override def get(id: Id): Option[Item] = { super.get(id).map(result = logger.info(s\"get($id) = $result\")) } } val itemDao: ItemDao = new ItemDaoImpl(...) extends LoggedItemDaoWrapper { override def ec = yourEc } The initialization code is not as clear as before since we provide ExecutionContext through override mechanism, and now we need to keep in mind initialization order because it’s easy to get NullPointerException there.\\n Initialization gets uglier if we have many wrappers for a class with different dependencies.\nIt can become even worse if we have Tagless Final.\\n When we write wrappers with TF we have to keep granularity of type classes, but when it comes to initialization, we’re doomed because different wrappers require different type class instances to be provided as function definitions.\\n Since we can’t ask for a type class via context bounds we have to use the same mechanism as shown before.\nHere’s an example how TF code might look like:\ntrait ItemDao[F[_]] { def upsert(item: Item): F[Unit] def get(id: Id): F[Option[Item]] } trait LoggedItemDaoWrapper[F[_]] extends ItemDao[F] with StrictLogging { implicit protected def mt: MonadThrow[F] abstract override def upsert(item: Item): F[Unit] = { super.upsert(item).attemptTap(...) } abstract override def get(id: Id): F[Option[Item]] = { super.get(id).attemptTap(...) } } val itemDao: ItemDao[F] = new ItemDaoImpl[F](...) extends LoggedItemDaoWrapper[F] with MeteredItemDaoWrapper[F] with TimeoutItemDaoWrapper[F] { override def mt: MonadThrow[F] = async override def at: ApplicativeError[F] = async override def concurrent: Concurrent[F] = async override def timer: Timer[F] = _timer override def gauge: Gauge = methodCallGauge } In order to reduce the amount of boilerplate and to make sure function names are the same everywhere, we’d want to implement type class providers.\ntrait MonadThrowSupport[F[_]] extends ApplicativeThrowSupport[F] { implicit protected def mt: MonadThrow[F] override implicit protected def at: ApplicativeError[F] = mt } trait LoggingSupport[F[_]] extends MonadThrowSupport[F] with StrictLogging trait LoggedItemDaoWrapper[F[_]] extends ItemDao[F] with LoggingSupport[F] { abstract override def upsert(item: Item): F[Unit] = { super.upsert(item).attemptTap(...) } abstract override def get(id: Id): F[Option[Item]] = { super.get(id).attemptTap(...) } } And then we’d want to make a super-provider for everything to reduce boilerplate in initialization code.\ntrait SuperProvider[F[_]] extends MonadThrowSupport[F] with ConcurrentSupport[F] with TimerSupport[F] with ClockSupport[F] with PrometheusGaugeSupport { override def mt: MonadThrow[F] = async override def concurrent: Concurrent[F] = async override def timer: Timer[F] = _timer override def clock: Clock[F] = _clock override def gauge: Gauge = methodCallGauge } val itemDao: ItemDao[F] = new ItemDaoImpl[F](...) extends LoggedItemDaoWrapper[F] with MeteredItemDaoWrapper[F] with TimeoutItemDaoWrapper[F] with SuperProvider[F] We managed to hide all the ugly stuff behind SuperProvider trait and support traits, but it’s hard to reason about provided dependencies and their initialization.\\n Initialization of components themselves looks clean but there’s a strong feeling that Tagless Final went wrong and code shouldn’t be written this way.\n","wordCount":"771","inLanguage":"en","datePublished":"2022-02-20T21:55:20+03:00","dateModified":"2022-02-20T21:55:20+03:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://awethon.github.io/posts/scala-wrappers/"},"publisher":{"@type":"Organization","name":"Awethon's Page","logo":{"@type":"ImageObject","url":"http://awethon.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=http://awethon.github.io/ accesskey=h title="Awethon's Page (Alt + H)">Awethon's Page</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu onscroll=menu_on_scroll()>
<li>
<a href=http://awethon.github.io/posts/ title=Posts>
<span>Posts</span>
</a>
</li>
<li>
<a href=http://awethon.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=http://awethon.github.io/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li></ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Different ways to make wrappers in Scala 2.x
</h1>
<div class=post-meta>February 20, 2022
|&nbsp;<a href=https://github.com/Awethon/awethon.github.io/blob/master/content/posts/scala-wrappers.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header>
<div class=post-content>
<p>This article is made to overview different approaches to make wrappers in Scala.\n
Wrapper pattern is useful when you need add additional logic to methods of a class: logging, metering, tracing, timeouts, retries. It helps to keep code clean and focused on business logic.
Scala is a great language and provides many ways to create wrappers. Maybe even too many.\n
I decided to create this article because it seems that there&rsquo;s no consensus between Scala developers on how to write them and no clear understanding of downsides and limitations.</p>
<p>I&rsquo;m going to review the following ways: trait mixin, class wrapper, and tofu mid.</p>
<p>Let&rsquo;s introduce a simple trait to start with:
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>ItemDao</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Unit</span>
  <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]</span>
<span style=color:#f92672>}</span></code></pre></div></p>
<p>One of the possible ways to create a wrapper is trait mixin technique.\n
We just need to make a trait that calls parent implementation of a method, and write our code.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>ItemDao</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>StrictLogging</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Unit</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
    logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;upsert(</span><span style=color:#e6db74>$item</span><span style=color:#e6db74>) is called&#34;</span><span style=color:#f92672>)</span>
    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span>upsert<span style=color:#f92672>(</span>item<span style=color:#f92672>)</span>
    logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;upsert(</span><span style=color:#e6db74>$item</span><span style=color:#e6db74>) = ()&#34;</span><span style=color:#f92672>)</span>
  <span style=color:#f92672>}</span>

  <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
    logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;get(</span><span style=color:#e6db74>$id</span><span style=color:#e6db74>) is called&#34;</span><span style=color:#f92672>)</span>
    <span style=color:#66d9ef>val</span> result <span style=color:#66d9ef>=</span> <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span>get<span style=color:#f92672>(</span>id<span style=color:#f92672>)</span>
    logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;get(</span><span style=color:#e6db74>$id</span><span style=color:#e6db74>) = </span><span style=color:#e6db74>$result</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>)</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span></code></pre></div>
<p>To make it work all we need to do is to connect it to our implementation:
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ItemDaoImpl</span><span style=color:#f92672>(...)</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span></code></pre></div></p>
<p>So far it looks nice and seems easy to understand.\n
Unfortunately, things become messy if there are dependencies to provide.</p>
<p>Let&rsquo;s make our trait to have asynchronous interface:
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>ItemDao</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Future</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Unit</span><span style=color:#f92672>]</span>
  <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Future</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]]</span>
<span style=color:#f92672>}</span></code></pre></div></p>
<p>If we have an interface that returns scala.concurrent.Future, then we have to provide ExecutionContext to our wrappers to be able to call map, flatMap, and other methods.\n
Many developers create global single thread execution context to keep things simple, but let&rsquo;s pretend I didn&rsquo;t say that.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>ItemDao</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>StrictLogging</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>def</span> ec<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ExecutionContext</span>

  <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Unit</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span>upsert<span style=color:#f92672>(</span>item<span style=color:#f92672>).</span>map<span style=color:#f92672>(</span><span style=color:#66d9ef>_</span> <span style=color:#66d9ef>=&gt;</span> logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;upsert(</span><span style=color:#e6db74>$item</span><span style=color:#e6db74>) = ()&#34;</span><span style=color:#f92672>))</span>
  <span style=color:#f92672>}</span>

  <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span>get<span style=color:#f92672>(</span>id<span style=color:#f92672>).</span>map<span style=color:#f92672>(</span>result <span style=color:#66d9ef>=&gt;</span> logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;get(</span><span style=color:#e6db74>$id</span><span style=color:#e6db74>) = </span><span style=color:#e6db74>$result</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>))</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span></code></pre></div>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>val</span> itemDao<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ItemDao</span> <span style=color:#f92672>=</span>
  <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ItemDaoImpl</span><span style=color:#f92672>(...)</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> ec <span style=color:#66d9ef>=</span> yourEc
  <span style=color:#f92672>}</span></code></pre></div>
<p>The initialization code is not as clear as before since we provide ExecutionContext through override mechanism, and now we need to keep in mind initialization order because it&rsquo;s easy to get NullPointerException there.\n
Initialization gets uglier if we have many wrappers for a class with different dependencies.</p>
<p>It can become even worse if we have Tagless Final.\n
When we write wrappers with TF we have to keep granularity of type classes, but when it comes to initialization, we&rsquo;re doomed because different wrappers require different type class instances to be provided as function definitions.\n
Since we can&rsquo;t ask for a type class via context bounds we have to use the same mechanism as shown before.</p>
<p>Here&rsquo;s an example how TF code might look like:</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>ItemDao</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>_</span><span style=color:#f92672>]]</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Unit</span><span style=color:#f92672>]</span>
  <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]]</span>
<span style=color:#f92672>}</span>

<span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>_</span><span style=color:#f92672>]]</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>ItemDao</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>StrictLogging</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>def</span> mt<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>MonadThrow</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>

  <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Unit</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span>upsert<span style=color:#f92672>(</span>item<span style=color:#f92672>).</span>attemptTap<span style=color:#f92672>(...)</span>
  <span style=color:#f92672>}</span>

  <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span>get<span style=color:#f92672>(</span>id<span style=color:#f92672>).</span>attemptTap<span style=color:#f92672>(...)</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>

<span style=color:#66d9ef>val</span> itemDao<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ItemDao</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span>
  <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ItemDaoImpl</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>](...)</span>
    <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
    <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>MeteredItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
    <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>TimeoutItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
      <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> mt<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>MonadThrow</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> async
      <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> at<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ApplicativeError</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> async
      <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> concurrent<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Concurrent</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> async
      <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> timer<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Timer</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>_timer</span>
      <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> gauge<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Gauge</span> <span style=color:#f92672>=</span> methodCallGauge
  <span style=color:#f92672>}</span></code></pre></div>
<p>In order to reduce the amount of boilerplate and to make sure function names are the same everywhere, we&rsquo;d want to implement type class providers.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>MonadThrowSupport</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>_</span><span style=color:#f92672>]]</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>ApplicativeThrowSupport</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>def</span> mt<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>MonadThrow</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>

    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>def</span> at<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ApplicativeError</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> mt
<span style=color:#f92672>}</span>

<span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>LoggingSupport</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>_</span><span style=color:#f92672>]]</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>MonadThrowSupport</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>StrictLogging</span>

<span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>_</span><span style=color:#f92672>]]</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>ItemDao</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>LoggingSupport</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Unit</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span>upsert<span style=color:#f92672>(</span>item<span style=color:#f92672>).</span>attemptTap<span style=color:#f92672>(...)</span>
  <span style=color:#f92672>}</span>

  <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span>get<span style=color:#f92672>(</span>id<span style=color:#f92672>).</span>attemptTap<span style=color:#f92672>(...)</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span></code></pre></div>
<p>And then we&rsquo;d want to make a super-provider for everything to reduce boilerplate in initialization code.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>SuperProvider</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>_</span><span style=color:#f92672>]]</span>
  <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>MonadThrowSupport</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
  <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>ConcurrentSupport</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
  <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>TimerSupport</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
  <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>ClockSupport</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
  <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>PrometheusGaugeSupport</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> mt<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>MonadThrow</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> async
    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> concurrent<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Concurrent</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> async
    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> timer<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Timer</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>_timer</span>
    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> clock<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Clock</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>_clock</span>
    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> gauge<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Gauge</span> <span style=color:#f92672>=</span> methodCallGauge
<span style=color:#f92672>}</span>

<span style=color:#66d9ef>val</span> itemDao<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ItemDao</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span>
  <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ItemDaoImpl</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>](...)</span>
    <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
    <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>MeteredItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
    <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>TimeoutItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
    <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>SuperProvider</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span></code></pre></div>
<p>We managed to hide all the ugly stuff behind SuperProvider trait and support traits, but it&rsquo;s hard to reason about provided dependencies and their initialization.\n
Initialization of components themselves looks clean but there&rsquo;s a strong feeling that Tagless Final went wrong and code shouldn&rsquo;t be written this way.</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=http://awethon.github.io/tags/scala/>scala</a></li>
</ul>
</footer>
</article>
</main><footer class=footer>
<span>&copy; 2022 <a href=http://awethon.github.io/>Awethon's Page</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script defer src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>