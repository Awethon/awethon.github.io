<!doctype html><html lang=en dir=auto>
<head>
<meta name=google-site-verification content="qgixNnkm2LoCsgWFtvfJRVqnkpqtr1Xzc5YTPoCL2zc">
<meta name=yandex-verification content="c25e903254c44b74"><meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge">
<meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no">
<meta name=robots content="index, follow">
<title>Different ways to implement wrappers in Scala 2.x | Awethon's Page</title>
<meta name=keywords content="scala">
<meta name=description content="The wrapper pattern (or the proxy pattern) is a useful way of adding extra logic to methods of a class: logging, metering, tracing, timeouts, retries. It helps to keep code clean and focused on business logic.
Scala is a great language and provides many ways to create wrappers. Maybe even too many.
I&rsquo;ve decided to create this article because it seems that there&rsquo;s no consensus among Scala developers on how to write them and no clear understanding of downsides and limitations.">
<meta name=author content>
<link rel=canonical href=https://awethon.github.io/posts/scala-wrappers/>
<link href=/assets/css/stylesheet.min.d08f6c302eba3eaecd589684c093cecdfe7dfb8745a207401bd0583d3bb31837.css integrity="sha256-0I9sMC66Pq7NWJaEwJPOzf59+4dFogdAG9BYPTuzGDc=" rel="preload stylesheet" as=style>
<link rel=icon href=https://awethon.github.io/favicon.ico>
<link rel=icon type=image/png sizes=16x16 href=https://awethon.github.io/favicon-16x16.png>
<link rel=icon type=image/png sizes=32x32 href=https://awethon.github.io/favicon-32x32.png>
<link rel=apple-touch-icon href=https://awethon.github.io/apple-touch-icon.png>
<link rel=mask-icon href=https://awethon.github.io/safari-pinned-tab.svg>
<meta name=theme-color content="#2e2e33">
<meta name=msapplication-TileColor content="#2e2e33">
<meta name=generator content="Hugo 0.92.2">
<meta property="og:title" content="Different ways to implement wrappers in Scala 2.x">
<meta property="og:description" content="The wrapper pattern (or the proxy pattern) is a useful way of adding extra logic to methods of a class: logging, metering, tracing, timeouts, retries. It helps to keep code clean and focused on business logic.
Scala is a great language and provides many ways to create wrappers. Maybe even too many.
I&rsquo;ve decided to create this article because it seems that there&rsquo;s no consensus among Scala developers on how to write them and no clear understanding of downsides and limitations.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://awethon.github.io/posts/scala-wrappers/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2022-02-20T21:55:20+03:00">
<meta property="article:modified_time" content="2022-02-20T21:55:20+03:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="Different ways to implement wrappers in Scala 2.x">
<meta name=twitter:description content="The wrapper pattern (or the proxy pattern) is a useful way of adding extra logic to methods of a class: logging, metering, tracing, timeouts, retries. It helps to keep code clean and focused on business logic.
Scala is a great language and provides many ways to create wrappers. Maybe even too many.
I&rsquo;ve decided to create this article because it seems that there&rsquo;s no consensus among Scala developers on how to write them and no clear understanding of downsides and limitations.">
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://awethon.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Different ways to implement wrappers in Scala 2.x","item":"https://awethon.github.io/posts/scala-wrappers/"}]}</script>
<script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Different ways to implement wrappers in Scala 2.x","name":"Different ways to implement wrappers in Scala 2.x","description":"The wrapper pattern (or the proxy pattern) is a useful way of adding extra logic to methods of a class: logging, metering, tracing, timeouts, retries. It helps to keep code clean and focused on business logic.\nScala is a great language and provides many ways to create wrappers. Maybe even too many.\nI\u0026rsquo;ve decided to create this article because it seems that there\u0026rsquo;s no consensus among Scala developers on how to write them and no clear understanding of downsides and limitations.","keywords":["scala"],"articleBody":"The wrapper pattern (or the proxy pattern) is a useful way of adding extra logic to methods of a class: logging, metering, tracing, timeouts, retries. It helps to keep code clean and focused on business logic.\nScala is a great language and provides many ways to create wrappers. Maybe even too many.\nI’ve decided to create this article because it seems that there’s no consensus among Scala developers on how to write them and no clear understanding of downsides and limitations.\n Table of Contents  Trait mixin Classic wrapper class Tofu Mid Pros and Cons  Trait mixin Classic wrapper class Tofu Mid   Conclusion    Trait mixin One of the possible ways to create a wrapper is the trait mixin technique.\nLet’s introduce a simple trait to start with: trait ItemDao { def upsert(item: Item): Unit def get(id: Id): Option[Item] }\nTo write a mixin wrapper for ItemDao we need to create the trait that extends ItemDao interface and make an abstract override to change methods behavior.\ntrait LoggedItemDaoWrapper extends ItemDao with StrictLogging { abstract override def upsert(item: Item): Unit = { logger.info(s\"upsert($item) is called\") super.upsert(item) logger.info(s\"upsert($item) = ()\") } abstract override def get(id: Id): Option[Item] = { logger.info(s\"get($id) is called\") val result = super.get(id) logger.info(s\"get($id) = $result\") } } To make it work mixin wrapper should be mixed into implementation: new ItemDaoImpl(...) extends LoggedItemDaoWrapper\nSo far it looks nice and seems easy to understand.\nUnfortunately, things become messy if there are dependencies to provide.\nLet’s make our trait to have asynchronous interface: trait ItemDao { def upsert(item: Item): Future[Unit] def get(id: Id): Future[Option[Item]] } If a trait has an interface that returns scala.concurrent.Future, then ExecutionContext must be provided to our wrappers to be able to call map, flatMap, and other methods.\nMany developers create global single thread execution context to keep things simple, but let’s pretend I didn’t say that.\ntrait LoggedItemDaoWrapper extends ItemDao with StrictLogging { protected implicit def ec: ExecutionContext abstract override def upsert(item: Item): Future[Unit] = { super.upsert(item).map(_ = logger.info(s\"upsert($item) = ()\")) } abstract override def get(id: Id): Future[Option[Item]] = { super.get(id).map(result = logger.info(s\"get($id) = $result\")) } } val itemDao: ItemDao = new ItemDaoImpl(...) extends LoggedItemDaoWrapper { override def ec = yourEc } The code of initialization is not as clear as before because ExecutionContext has to be provided through the override def mechanism. Initialization order has to be kept in mind because it’s possible to get NullPointerException there.\nThe more dependencies are stacked together the worse the code looks.\nIt becomes even worse with Tagless Final. When we write wrappers using TF we want to keep granularity of type classes, but when it comes to initialization, we’re doomed because different wrappers require different type class instances to be provided as function definitions. Since a type class cannot be provided via context bounds, we have to use the same mechanism as shown before.\nHere’s an example of what TF code might look like:\ntrait ItemDao[F[_]] { def upsert(item: Item): F[Unit] def get(id: Id): F[Option[Item]] } trait LoggedItemDaoWrapper[F[_]] extends ItemDao[F] with StrictLogging { implicit protected def mt: MonadThrow[F] abstract override def upsert(item: Item): F[Unit] = { super.upsert(item).attemptTap(...) } abstract override def get(id: Id): F[Option[Item]] = { super.get(id).attemptTap(...) } } val itemDao: ItemDao[F] = new ItemDaoImpl[F](...) extends LoggedItemDaoWrapper[F] with MeteredItemDaoWrapper[F] with TimeoutItemDaoWrapper[F] { override def mt: MonadThrow[F] = async override def at: ApplicativeError[F] = async override def concurrent: Concurrent[F] = async override def timer: Timer[F] = _timer override def gauge: Gauge = methodCallGauge }  In order to reduce the amount of boilerplate and make sure dependencies names are the same for the same dependencies, type class provider traits have to be implemented.\ntrait MonadThrowProvider[F[_]] extends ApplicativeThrowProvider[F] { implicit protected def mt: MonadThrow[F] override implicit protected def at: ApplicativeError[F] = mt } trait LoggingProvider[F[_]] extends MonadThrowProvider[F] with StrictLogging trait LoggedItemDaoWrapper[F[_]] extends ItemDao[F] with LoggingProvider[F] { abstract override def upsert(item: Item): F[Unit] = { super.upsert(item).attemptTap(...) } abstract override def get(id: Id): F[Option[Item]] = { super.get(id).attemptTap(...) } } The composition of all providers into a super-provider might be a good idea to reduce boilerplate in the initialization code.\ntrait SuperProvider[F[_]] extends MonadThrowProvider[F] with ConcurrentProvider[F] with TimerProvider[F] with ClockProvider[F] with PrometheusGaugeProvider { override def mt: MonadThrow[F] = async override def concurrent: Concurrent[F] = async override def timer: Timer[F] = _timer override def clock: Clock[F] = _clock override def gauge: Gauge = methodCallGauge } val itemDao: ItemDao[F] = new ItemDaoImpl[F](...) extends LoggedItemDaoWrapper[F] with MeteredItemDaoWrapper[F] with TimeoutItemDaoWrapper[F] with SuperProvider[F] We managed to hide all the ugly stuff behind SuperProvider trait and provider traits, but it’s hard to reason about provided dependencies and their initialization.\nInitialization of components themselves looks clean, but there’s a strong feeling that Tagless Final went wrong and code shouldn’t be written this way.\nClassic wrapper class Writing a wrapper via class is a standard way of doing it in OOP languages. The question is how well it is able to handle Tagless Final.\nI’ll write all three versions together since they look very similar: class LoggedItemDaoWrapper(itemDao: ItemDao) extends ItemDao with StrictLogging { override def upsert(item: Item): Unit = { logger.info(s\"upsert($item) is called\") itemDao.upsert(item) logger.info(s\"upsert($item) = ()\") } override def get(id: Id): Option[Item] = { logger.info(s\"get($id) is called\") val result = itemDao.get(id) logger.info(s\"get($id) = $result\") } } class LoggedItemDaoWrapper(itemDao: ItemDao)(implicit ec: ExecutionContext) extends ItemDao with StrictLogging { override def upsert(item: Item): Future[Unit] = { itemDao.upsert(item).map(_ = logger.info(s\"upsert($item) = ()\")) } override def get(id: Id): Future[Option[Item]] = { super.get(id).map(result = logger.info(s\"get($id) = $result\")) } } class LoggedItemDaoWrapper[F[_]: MonadThrow](itemDao: ItemDao[F]) extends ItemDao[F] with StrictLogging { override def upsert(item: Item): F[Unit] = { itemDao.upsert(item).attemptTap(...) } override def get(id: Id): F[Option[Item]] = { itemDao.get(id).attemptTap(...) } } Looks nice! Easy to read even with Tagless Final approach. But what about initialization?\nWell, implicits reduce boilerplate significantly, composition instead of inheritance makes dependencies easy to reason about.\nval itemDao: ItemDao[F] = new TimeoutItemDaoWrapper[F](timeoutsConfig)( new MeteredItemDaoWrapper[F](gauge)( new LoggedItemDaoWrapper[F]( new ItemDaoImpl[F](...) ) ) ) Although initialization is in reverse order (compared to mixins) might be confusing.\nWith the power of Scala implicits, it is pretty easy to make code look like mixins are being added to a class.\nimplicit class WrapperHelper[A](private val a: A) extends AnyVal { def `with`[B : A](wrap: A = B): B = wrap(a) } I think it’s a great and simple solution that helps to migrate from mixins smoothly. To achieve the best result, make sure that wrappers have a companion with apply function with dependencies listed before to-be-wrapped class and that dependencies and class are separated with curring e.g. class Wrapper[F[_]: TC1: TC2](dep1: Dep1, dep2: Dep2[F])(o: MyClass[F]) extends MyClass[F] { ... } So initialization code will look like this: myClassImpl .`with`(Wrapper1(dep1, dep2)) .`with`(Wrapper2(dep3))\nTofu Mid Tofu is a scala library made by Tagless Final enthusiasts that boosts TF experience to new levels. It has many features worth checking out, but the feature we need for wrappers is Mid.\nMid is not an easy abstraction to understand. It is even harder to understand the deriving mechanism of type class ApplyK.\nNevertheless, it doesn’t make it hard to use. Mid is a function from the result of the original method to the result of the same type: F[A] = F[A].\n@derive(applyK) trait ItemDao[F[_]] { def upsert(item: Item): F[Unit] def get(id: Id): F[Option[Item]] } class LoggingItemDaoWrapper[F[_]: Sync] extends ItemDao[Mid[F, *]] with StrictLogging { private def info(str: String): F[Unit] = Sync[F].delay(logger.info(str)) override def upsert(item: Item): Mid[F, Unit] = { upsert = info(s\"upserting $item\") * upsert  info(s\"upsert of $itemis successful\") } override def get(id: Id): Mid[F, Option[Item]] = { get = info(s\"getting $id\") * get.flatTap(result = info(s\"get of $idis successful = $result\")) } } class TimeoutItemDaoWrapper[F[_]: Concurrent](timeoutValue: FiniteDuration)(implicit timer: Timer[F]) extends ItemDao[Mid[F, *]] { override def upsert(item: Item): Mid[F, Unit] = _.timeout(timeoutValue) override def get(id: Id): Mid[F, Option[Item]] = _.timeout(timeoutValue) } class NoOpItemDaoWrapper[F[_]] extends ItemDao[Mid[F, *]] { override def upsert(item: Item): Mid[F, Unit] = identity override def get(id: Id): Mid[F, Option[Item]] = identity } val service = new ItemDaoImpl[F](...) val logging = new LoggingItemDaoWrapper[F] val timeouts = new TimeoutItemDaoWrapper[F](timeoutValue) val noop = new NoOpItemDaoWrapper[F] // logging before // timeouts before // noop before // original method // noop after // timeouts after // logging after (logging |+| timeouts |+| noop).attach(service) As you can see code looks very clean without a need to pass arguments to the original method. But internal mechanism of Mid may not be clear.\nTo put things simple, all the mid wrappers are composed like mid2.andThen(mid1) and method call chain in composite wrapper looks like x = mid1.method(mid2.method(x)). After composition, Mid wrapper attaches to implementation. Attachment means application of implementation to a wrapper and as a result it returns wrapped instance of a class: compositeMid.apply(impl).\nSo basically, when you introduce a type like ItemDao[Mid[F, *]], you introduce a wrapper.\nUnfortunately, Tofu Mid usage is limited to Tagless Final algebras due to ApplyK magic.\nPros and Cons At the end of the article, it might seem that choice is clear, however after digging into details, many limitations and downsides are found.\nTrait mixin Pros:\n+ Saves specific type after wrapping. new ItemDaoImpl(...) extends LoggedItemDao has type ItemDaoImpl with LoggedItemDao. So it is possible to use any methods from ItemDaoImpl.\n+ Only those methods that are to be wrapped need to be present in wrappers. If you have a trait with 10 methods but want to add logging to one of them, then only one abstract override of the method needs to be written in a mixin.\n+ Doesn’t require any libraries to use.\n+ Well explained in scala books.\nCons:\n- Providing dependencies creates a lot of boilerplate.\n- Wrapping uses an inheritance mechanism. The order of initialization may not be clear.\n- Might lead to NPEs during initialization.\n- Looks ugly with Tagless Final.\nClassic wrapper class Pros:\n+ Easy-to-understand GOF pattern from OOP languages.\n+ Doesn’t get complicated no matter how many wrappers are composed.\n+ It’s possible to make initialization look like with mixins.\n+ Easy to use with Tagless Final.\n+ Doesn’t require any libraries to use.\nCons:\n- All the methods of a trait have to be overridden in a wrapper.\n- StrictLogging gets wrapper class instead of implementation by default. It makes it hard to find the source of log in case where wrapper is used for many implementations.\n- A wrapper loses implementation type after wrapping making it impossible to call methods specific to the implementation.\nTofu Mid Pros:\n+ No need to call an original method directly. Less boilerplate.\n+ Has dsl for initialization that is easy to use.\nCons:\n- The same problem with StrictLogging as for classic wrapper class. Tofu provides Logging type class but its implementation is too specific.\n- Mid wrapper also loses original type.\n- Even though all the methods of a trait have to be overridden, it’s much easier with mid. x = x or in other words identity is enough.\n- One type parameter type has to be introduced to do initialization. It won’t work automatically with type KVDao[F[_], K, V] or similar.\n- The annotation that derives ApplyK has to be added to a class or has to be derived manually.\n- ApplyK cannot be derived if at least one of the methods returns anything other than F[…]. So it won’t be derived if a trait has a constant method like def groupId: String or a method that returns fs2.Stream.\n- Mid usage is limited to TF algebras and only to them.\nConclusion Although usage of Mid reduces boilerplate in wrappers it adds boilerplate in ApplyK derivation and temporary one type parameter introduction cases.\nUsage of Mid is very limited and cannot be used as a universal wrapping approach unless you have an ideal Tagless Final application which is a rare thing in reality.\nI’d recommend using classic wrapper classes as it is a comprehensive, readable, and easy-to-understand solution.\n","wordCount":"1956","inLanguage":"en","datePublished":"2022-02-20T21:55:20+03:00","dateModified":"2022-02-20T21:55:20+03:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://awethon.github.io/posts/scala-wrappers/"},"publisher":{"@type":"Organization","name":"Awethon's Page","logo":{"@type":"ImageObject","url":"https://awethon.github.io/favicon.ico"}}}</script>
</head>
<body id=top>
<script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add('dark'):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove('dark'):window.matchMedia('(prefers-color-scheme: dark)').matches&&document.body.classList.add('dark')</script>
<noscript>
<style type=text/css>#theme-toggle,.top-link{display:none}</style>
<style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style>
</noscript>
<header class=header>
<nav class=nav>
<div class=logo>
<a href=https://awethon.github.io/ accesskey=h title="Awethon's Page (Alt + H)">Awethon's Page</a>
<span class=logo-switches>
<button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
</button>
</span>
</div>
<ul id=menu onscroll=menu_on_scroll()>
<li>
<a href=https://awethon.github.io/posts/ title=Posts>
<span>Posts</span>
</a>
</li>
<li>
<a href=https://awethon.github.io/tags/ title=Tags>
<span>Tags</span>
</a>
</li>
<li>
<a href=https://awethon.github.io/search/ title="Search (Alt + /)" accesskey=/>
<span>Search</span>
</a>
</li></ul>
</nav>
</header>
<main class=main>
<article class=post-single>
<header class=post-header>
<h1 class=post-title>
Different ways to implement wrappers in Scala 2.x
</h1>
<div class=post-meta>February 20, 2022
|&nbsp;<a href=https://github.com/Awethon/awethon.github.io/blob/master/content/posts/scala-wrappers.md rel="noopener noreferrer" target=_blank>Suggest Changes</a>
</div>
</header>
<div class=post-content>
<p>The wrapper pattern (or the proxy pattern) is a useful way of adding extra logic to methods of a class: logging, metering, tracing, timeouts, retries. It helps to keep code clean and focused on business logic.<br>
Scala is a great language and provides many ways to create wrappers. Maybe even too many.</p>
<p>I&rsquo;ve decided to create this article because it seems that there&rsquo;s no consensus among Scala developers on how to write them and no clear understanding of downsides and limitations.</p>
<br>
<h3>Table of Contents</h3>
<div class=toc>
<nav id=TableOfContents>
<ul>
<li><a href=#trait-mixin>Trait mixin</a></li>
<li><a href=#classic-wrapper-class>Classic wrapper class</a></li>
<li><a href=#tofu-mid>Tofu Mid</a></li>
<li><a href=#pros-and-cons>Pros and Cons</a>
<ul>
<li><a href=#trait-mixin-1>Trait mixin</a></li>
<li><a href=#classic-wrapper-class-1>Classic wrapper class</a></li>
<li><a href=#tofu-mid-1>Tofu Mid</a></li>
</ul>
</li>
<li><a href=#conclusion>Conclusion</a></li>
</ul>
</nav>
</div>
<h2 id=trait-mixin>Trait mixin<a hidden class=anchor aria-hidden=true href=#trait-mixin>#</a></h2>
<p>One of the possible ways to create a wrapper is the trait mixin technique.</p>
<p>Let&rsquo;s introduce a simple trait to start with:
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>ItemDao</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Unit</span>
  <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]</span>
<span style=color:#f92672>}</span></code></pre></div></p>
<p>To write a mixin wrapper for ItemDao we need to create the trait that extends ItemDao interface and make an abstract override to change methods behavior.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>ItemDao</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>StrictLogging</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Unit</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
    logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;upsert(</span><span style=color:#e6db74>$item</span><span style=color:#e6db74>) is called&#34;</span><span style=color:#f92672>)</span>
    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span>upsert<span style=color:#f92672>(</span>item<span style=color:#f92672>)</span>
    logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;upsert(</span><span style=color:#e6db74>$item</span><span style=color:#e6db74>) = ()&#34;</span><span style=color:#f92672>)</span>
  <span style=color:#f92672>}</span>

  <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
    logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;get(</span><span style=color:#e6db74>$id</span><span style=color:#e6db74>) is called&#34;</span><span style=color:#f92672>)</span>
    <span style=color:#66d9ef>val</span> result <span style=color:#66d9ef>=</span> <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span>get<span style=color:#f92672>(</span>id<span style=color:#f92672>)</span>
    logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;get(</span><span style=color:#e6db74>$id</span><span style=color:#e6db74>) = </span><span style=color:#e6db74>$result</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>)</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span></code></pre></div>
<p>To make it work mixin wrapper should be mixed into implementation:
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ItemDaoImpl</span><span style=color:#f92672>(...)</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span></code></pre></div></p>
<p>So far it looks nice and seems easy to understand.<br>
Unfortunately, things become messy if there are dependencies to provide.</p>
<p>Let&rsquo;s make our trait to have asynchronous interface:
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>ItemDao</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Future</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Unit</span><span style=color:#f92672>]</span>
  <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Future</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]]</span>
<span style=color:#f92672>}</span></code></pre></div>
<br>
If a trait has an interface that returns <code>scala.concurrent.Future</code>, then <code>ExecutionContext</code> must be provided to our wrappers to be able to call <code>map</code>, <code>flatMap</code>, and other methods.<br>
Many developers create global single thread execution context to keep things simple, but let&rsquo;s pretend I didn&rsquo;t say that.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>ItemDao</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>StrictLogging</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>def</span> ec<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ExecutionContext</span>

  <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Future</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Unit</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span>upsert<span style=color:#f92672>(</span>item<span style=color:#f92672>).</span>map<span style=color:#f92672>(</span><span style=color:#66d9ef>_</span> <span style=color:#66d9ef>=&gt;</span> logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;upsert(</span><span style=color:#e6db74>$item</span><span style=color:#e6db74>) = ()&#34;</span><span style=color:#f92672>))</span>
  <span style=color:#f92672>}</span>

  <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Future</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span>get<span style=color:#f92672>(</span>id<span style=color:#f92672>).</span>map<span style=color:#f92672>(</span>result <span style=color:#66d9ef>=&gt;</span> logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;get(</span><span style=color:#e6db74>$id</span><span style=color:#e6db74>) = </span><span style=color:#e6db74>$result</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>))</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span></code></pre></div>
<p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>val</span> itemDao<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ItemDao</span> <span style=color:#f92672>=</span>
  <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ItemDaoImpl</span><span style=color:#f92672>(...)</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> ec <span style=color:#66d9ef>=</span> yourEc
  <span style=color:#f92672>}</span></code></pre></div>
<br>
The code of initialization is not as clear as before because <code>ExecutionContext</code> has to be provided through the <code>override def</code> mechanism. Initialization order has to be kept in mind because it&rsquo;s possible to get <code>NullPointerException</code> there.<br>
The more dependencies are stacked together the worse the code looks.</p>
<p>It becomes even worse with Tagless Final. When we write wrappers using TF we want to keep granularity of type classes, but when it comes to initialization, we&rsquo;re doomed because different wrappers require different type class instances to be provided as function definitions. Since a type class cannot be provided via context bounds, we have to use the same mechanism as shown before.</p>
<p>Here&rsquo;s an example of what TF code might look like:</p>
<p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>ItemDao</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>_</span><span style=color:#f92672>]]</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Unit</span><span style=color:#f92672>]</span>
  <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]]</span>
<span style=color:#f92672>}</span>

<span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>_</span><span style=color:#f92672>]]</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>ItemDao</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>StrictLogging</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>def</span> mt<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>MonadThrow</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>

  <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Unit</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span>upsert<span style=color:#f92672>(</span>item<span style=color:#f92672>).</span>attemptTap<span style=color:#f92672>(...)</span>
  <span style=color:#f92672>}</span>

  <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span>get<span style=color:#f92672>(</span>id<span style=color:#f92672>).</span>attemptTap<span style=color:#f92672>(...)</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>

<span style=color:#66d9ef>val</span> itemDao<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ItemDao</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span>
  <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ItemDaoImpl</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>](...)</span>
    <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
    <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>MeteredItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
    <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>TimeoutItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
      <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> mt<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>MonadThrow</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> async
      <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> at<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ApplicativeError</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> async
      <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> concurrent<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Concurrent</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> async
      <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> timer<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Timer</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>_timer</span>
      <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> gauge<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Gauge</span> <span style=color:#f92672>=</span> methodCallGauge
    <span style=color:#f92672>}</span> </code></pre></div>
<br>
In order to reduce the amount of boilerplate and make sure dependencies names are the same for the same dependencies, type class provider traits have to be implemented.</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>MonadThrowProvider</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>_</span><span style=color:#f92672>]]</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>ApplicativeThrowProvider</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>def</span> mt<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>MonadThrow</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>

    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>def</span> at<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ApplicativeError</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> mt
<span style=color:#f92672>}</span>

<span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>LoggingProvider</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>_</span><span style=color:#f92672>]]</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>MonadThrowProvider</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>StrictLogging</span>

<span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>_</span><span style=color:#f92672>]]</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>ItemDao</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>LoggingProvider</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Unit</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span>upsert<span style=color:#f92672>(</span>item<span style=color:#f92672>).</span>attemptTap<span style=color:#f92672>(...)</span>
  <span style=color:#f92672>}</span>

  <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span>get<span style=color:#f92672>(</span>id<span style=color:#f92672>).</span>attemptTap<span style=color:#f92672>(...)</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span></code></pre></div>
<p>The composition of all providers into a super-provider might be a good idea to reduce boilerplate in the initialization code.</p>
<p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>SuperProvider</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>_</span><span style=color:#f92672>]]</span>
  <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>MonadThrowProvider</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
  <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>ConcurrentProvider</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
  <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>TimerProvider</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
  <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>ClockProvider</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
  <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>PrometheusGaugeProvider</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> mt<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>MonadThrow</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> async
    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> concurrent<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Concurrent</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> async
    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> timer<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Timer</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>_timer</span>
    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> clock<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Clock</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>_clock</span>
    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> gauge<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Gauge</span> <span style=color:#f92672>=</span> methodCallGauge
<span style=color:#f92672>}</span>

<span style=color:#66d9ef>val</span> itemDao<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ItemDao</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span>
  <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ItemDaoImpl</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>](...)</span>
    <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
    <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>MeteredItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
    <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>TimeoutItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
    <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>SuperProvider</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span></code></pre></div>
<br>
We managed to hide all the ugly stuff behind SuperProvider trait and provider traits, but it&rsquo;s hard to reason about provided dependencies and their initialization.<br>
Initialization of components themselves looks clean, but there&rsquo;s a strong feeling that Tagless Final went wrong and code shouldn&rsquo;t be written this way.</p>
<h2 id=classic-wrapper-class>Classic wrapper class<a hidden class=anchor aria-hidden=true href=#classic-wrapper-class>#</a></h2>
<p>Writing a wrapper via class is a standard way of doing it in OOP languages. The question is how well it is able to handle Tagless Final.<br>
I&rsquo;ll write all three versions together since they look very similar:
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span><span style=color:#f92672>(</span>itemDao<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ItemDao</span><span style=color:#f92672>)</span>
  <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>ItemDao</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>StrictLogging</span> <span style=color:#f92672>{</span>
  
  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Unit</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
    logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;upsert(</span><span style=color:#e6db74>$item</span><span style=color:#e6db74>) is called&#34;</span><span style=color:#f92672>)</span>
    itemDao<span style=color:#f92672>.</span>upsert<span style=color:#f92672>(</span>item<span style=color:#f92672>)</span>
    logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;upsert(</span><span style=color:#e6db74>$item</span><span style=color:#e6db74>) = ()&#34;</span><span style=color:#f92672>)</span>
  <span style=color:#f92672>}</span>

  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
    logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;get(</span><span style=color:#e6db74>$id</span><span style=color:#e6db74>) is called&#34;</span><span style=color:#f92672>)</span>
    <span style=color:#66d9ef>val</span> result <span style=color:#66d9ef>=</span> itemDao<span style=color:#f92672>.</span>get<span style=color:#f92672>(</span>id<span style=color:#f92672>)</span>
    logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;get(</span><span style=color:#e6db74>$id</span><span style=color:#e6db74>) = </span><span style=color:#e6db74>$result</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>)</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span><span style=color:#f92672>(</span>itemDao<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ItemDao</span><span style=color:#f92672>)(</span><span style=color:#66d9ef>implicit</span> ec<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ExecutionContext</span><span style=color:#f92672>)</span>
  <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>ItemDao</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>StrictLogging</span> <span style=color:#f92672>{</span>
  
  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Future</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Unit</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
    itemDao<span style=color:#f92672>.</span>upsert<span style=color:#f92672>(</span>item<span style=color:#f92672>).</span>map<span style=color:#f92672>(</span><span style=color:#66d9ef>_</span> <span style=color:#66d9ef>=&gt;</span> logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;upsert(</span><span style=color:#e6db74>$item</span><span style=color:#e6db74>) = ()&#34;</span><span style=color:#f92672>))</span>
  <span style=color:#f92672>}</span>

  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Future</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span>get<span style=color:#f92672>(</span>id<span style=color:#f92672>).</span>map<span style=color:#f92672>(</span>result <span style=color:#66d9ef>=&gt;</span> logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;get(</span><span style=color:#e6db74>$id</span><span style=color:#e6db74>) = </span><span style=color:#e6db74>$result</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>))</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>_</span><span style=color:#f92672>]</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>MonadThrow</span><span style=color:#f92672>](</span>itemDao<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ItemDao</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>])</span>
  <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>ItemDao</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>StrictLogging</span> <span style=color:#f92672>{</span>
  
  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Unit</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
    itemDao<span style=color:#f92672>.</span>upsert<span style=color:#f92672>(</span>item<span style=color:#f92672>).</span>attemptTap<span style=color:#f92672>(...)</span>
  <span style=color:#f92672>}</span>

  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
    itemDao<span style=color:#f92672>.</span>get<span style=color:#f92672>(</span>id<span style=color:#f92672>).</span>attemptTap<span style=color:#f92672>(...)</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span></code></pre></div>
<br>
Looks nice! Easy to read even with Tagless Final approach. But what about initialization?<br>
Well, implicits reduce boilerplate significantly, composition instead of inheritance makes dependencies easy to reason about.</p>
<p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>val</span> itemDao<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ItemDao</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span>
  <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>TimeoutItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>](</span>timeoutsConfig<span style=color:#f92672>)(</span>
    <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>MeteredItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>](</span>gauge<span style=color:#f92672>)(</span>
      <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>](</span>
        <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ItemDaoImpl</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>](...)</span>
      <span style=color:#f92672>)</span>
    <span style=color:#f92672>)</span>
  <span style=color:#f92672>)</span></code></pre></div>
<br>
Although initialization is in reverse order (compared to mixins) might be confusing.<br>
With the power of Scala implicits, it is pretty easy to make code look like mixins are being added to a class.</p>
<p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WrapperHelper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>A</span><span style=color:#f92672>](</span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> a<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>A</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>AnyVal</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>def</span> `with`<span style=color:#f92672>[</span><span style=color:#66d9ef>B</span> <span style=color:#66d9ef>&gt;:</span> <span style=color:#66d9ef>A</span><span style=color:#f92672>](</span>wrap<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>A</span> <span style=color:#f92672>=&gt;</span> B<span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>B</span> <span style=color:#f92672>=</span> wrap<span style=color:#f92672>(</span>a<span style=color:#f92672>)</span>
<span style=color:#f92672>}</span></code></pre></div>
<br>
I think it&rsquo;s a great and simple solution that helps to migrate from mixins smoothly.
To achieve the best result, make sure that wrappers have a companion with <code>apply</code> function with dependencies listed before to-be-wrapped class and that dependencies and class are separated with curring e.g.
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala>  <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Wrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>_</span><span style=color:#f92672>]</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>TC1:</span> <span style=color:#66d9ef>TC2</span><span style=color:#f92672>](</span>dep1<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Dep1</span><span style=color:#f92672>,</span> dep2<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Dep2</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>])(</span>o<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>MyClass</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>])</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>MyClass</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#f92672>{</span> <span style=color:#f92672>...</span> <span style=color:#f92672>}</span></code></pre></div>
<br>
So initialization code will look like this:
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala>myClassImpl
  <span style=color:#f92672>.</span>`with`<span style=color:#f92672>(</span><span style=color:#a6e22e>Wrapper1</span><span style=color:#f92672>(</span>dep1<span style=color:#f92672>,</span> dep2<span style=color:#f92672>))</span>
  <span style=color:#f92672>.</span>`with`<span style=color:#f92672>(</span><span style=color:#a6e22e>Wrapper2</span><span style=color:#f92672>(</span>dep3<span style=color:#f92672>))</span></code></pre></div></p>
<h2 id=tofu-mid>Tofu Mid<a hidden class=anchor aria-hidden=true href=#tofu-mid>#</a></h2>
<p>Tofu is a scala library made by Tagless Final enthusiasts that boosts TF experience to new levels. It has many features worth checking out, but the feature we need for wrappers is <a href=https://docs.tofu.tf/docs/mid>Mid</a>.</p>
<p>Mid is not an easy abstraction to understand. It is even harder to understand the deriving mechanism of type class <code>ApplyK</code>.<br>
Nevertheless, it doesn&rsquo;t make it hard to use. Mid is a function from the result of the original method to the result of the same type: <code>F[A] => F[A]</code>.</p>
<p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=color:#a6e22e>@derive</span><span style=color:#f92672>(</span>applyK<span style=color:#f92672>)</span>
<span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>ItemDao</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>_</span><span style=color:#f92672>]]</span> <span style=color:#f92672>{</span>
  <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Unit</span><span style=color:#f92672>]</span>
  <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]]</span>
<span style=color:#f92672>}</span>

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LoggingItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>_</span><span style=color:#f92672>]</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Sync</span><span style=color:#f92672>]</span>
  <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>ItemDao</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Mid</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span>, <span style=color:#66d9ef>*</span><span style=color:#f92672>]]</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>StrictLogging</span> <span style=color:#f92672>{</span>

  <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>def</span> info<span style=color:#f92672>(</span>str<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>String</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Unit</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>Sync</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>].</span>delay<span style=color:#f92672>(</span>logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span>str<span style=color:#f92672>))</span>
  
  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Mid</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span>, <span style=color:#66d9ef>Unit</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span> upsert <span style=color:#66d9ef>=&gt;</span>
    info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;upserting </span><span style=color:#e6db74>$item</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>)</span> <span style=color:#f92672>*&gt;</span> upsert <span style=color:#f92672>&lt;*</span> info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;upsert of </span><span style=color:#e6db74>$item</span><span style=color:#e6db74> is successful&#34;</span><span style=color:#f92672>)</span>
  <span style=color:#f92672>}</span>
  
  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Mid</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span>, <span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span> get <span style=color:#66d9ef>=&gt;</span>
    info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;getting </span><span style=color:#e6db74>$id</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>)</span> <span style=color:#f92672>*&gt;</span> get<span style=color:#f92672>.</span>flatTap<span style=color:#f92672>(</span>result <span style=color:#66d9ef>=&gt;</span> info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;get of </span><span style=color:#e6db74>$id</span><span style=color:#e6db74> is successful = </span><span style=color:#e6db74>$result</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>))</span>
  <span style=color:#f92672>}</span>
<span style=color:#f92672>}</span>

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TimeoutItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>_</span><span style=color:#f92672>]</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Concurrent</span><span style=color:#f92672>](</span>timeoutValue<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>FiniteDuration</span><span style=color:#f92672>)(</span><span style=color:#66d9ef>implicit</span> timer<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Timer</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>])</span>
  <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>ItemDao</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Mid</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span>, <span style=color:#66d9ef>*</span><span style=color:#f92672>]]</span> <span style=color:#f92672>{</span>

  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Mid</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span>, <span style=color:#66d9ef>Unit</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#66d9ef>_</span><span style=color:#f92672>.</span>timeout<span style=color:#f92672>(</span>timeoutValue<span style=color:#f92672>)</span>

  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Mid</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span>, <span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]]</span> <span style=color:#66d9ef>=</span> <span style=color:#66d9ef>_</span><span style=color:#f92672>.</span>timeout<span style=color:#f92672>(</span>timeoutValue<span style=color:#f92672>)</span>
<span style=color:#f92672>}</span>

<span style=color:#66d9ef>class</span> <span style=color:#a6e22e>NoOpItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>_</span><span style=color:#f92672>]]</span>
  <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>ItemDao</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Mid</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span>, <span style=color:#66d9ef>*</span><span style=color:#f92672>]]</span> <span style=color:#f92672>{</span>

  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Mid</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span>, <span style=color:#66d9ef>Unit</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> identity

  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Mid</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span>, <span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]]</span> <span style=color:#66d9ef>=</span> identity
<span style=color:#f92672>}</span>

<span style=color:#66d9ef>val</span> service  <span style=color:#66d9ef>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ItemDaoImpl</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>](...)</span>
<span style=color:#66d9ef>val</span> logging  <span style=color:#66d9ef>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>LoggingItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
<span style=color:#66d9ef>val</span> timeouts <span style=color:#66d9ef>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>TimeoutItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>](</span>timeoutValue<span style=color:#f92672>)</span>
<span style=color:#66d9ef>val</span> noop     <span style=color:#66d9ef>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>NoOpItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>

<span style=color:#75715e>// logging before
</span><span style=color:#75715e>// timeouts before
</span><span style=color:#75715e>// noop before
</span><span style=color:#75715e>// original method
</span><span style=color:#75715e>// noop after
</span><span style=color:#75715e>// timeouts after
</span><span style=color:#75715e>// logging after
</span><span style=color:#75715e></span><span style=color:#f92672>(</span>logging <span style=color:#f92672>|+|</span> timeouts <span style=color:#f92672>|+|</span> noop<span style=color:#f92672>).</span>attach<span style=color:#f92672>(</span>service<span style=color:#f92672>)</span></code></pre></div>
<br>
As you can see code looks very clean without a need to pass arguments to the original method.
But internal mechanism of Mid may not be clear.</p>
<p>To put things simple, all the mid wrappers are composed like <code>mid2.andThen(mid1)</code> and method call chain in composite wrapper looks like <code>x => mid1.method(mid2.method(x))</code>.
After composition, Mid wrapper attaches to implementation.
Attachment means application of implementation to a wrapper and as a result it returns wrapped instance of a class: <code>compositeMid.apply(impl)</code>.<br>
So basically, when you introduce a type like <code>ItemDao[Mid[F, *]]</code>, you introduce a wrapper.</p>
<p>Unfortunately, Tofu Mid usage is limited to Tagless Final algebras due to <code>ApplyK</code> magic.</p>
<h2 id=pros-and-cons>Pros and Cons<a hidden class=anchor aria-hidden=true href=#pros-and-cons>#</a></h2>
<p>At the end of the article, it might seem that choice is clear, however after digging into details, many limitations and downsides are found.</p>
<h3 id=trait-mixin-1>Trait mixin<a hidden class=anchor aria-hidden=true href=#trait-mixin-1>#</a></h3>
<p>Pros:<br>
<strong>+</strong> Saves specific type after wrapping. <code>new ItemDaoImpl(...) extends LoggedItemDao</code> has type <code>ItemDaoImpl with LoggedItemDao</code>. So it is possible to use any methods from <code>ItemDaoImpl</code>.<br>
<strong>+</strong> Only those methods that are to be wrapped need to be present in wrappers. If you have a trait with 10 methods but want to add logging to one of them, then only one abstract override of the method needs to be written in a mixin.<br>
<strong>+</strong> Doesn&rsquo;t require any libraries to use.<br>
<strong>+</strong> Well explained in scala books.</p>
<p>Cons:<br>
<strong>-</strong> Providing dependencies creates a lot of boilerplate.<br>
<strong>-</strong> Wrapping uses an inheritance mechanism. The order of initialization may not be clear.<br>
<strong>-</strong> Might lead to NPEs during initialization.<br>
<strong>-</strong> Looks ugly with Tagless Final.</p>
<h3 id=classic-wrapper-class-1>Classic wrapper class<a hidden class=anchor aria-hidden=true href=#classic-wrapper-class-1>#</a></h3>
<p>Pros:<br>
<strong>+</strong> Easy-to-understand GOF pattern from OOP languages.<br>
<strong>+</strong> Doesn&rsquo;t get complicated no matter how many wrappers are composed.<br>
<strong>+</strong> It&rsquo;s possible to make initialization look like with mixins.<br>
<strong>+</strong> Easy to use with Tagless Final.<br>
<strong>+</strong> Doesn&rsquo;t require any libraries to use.</p>
<p>Cons:<br>
<strong>-</strong> All the methods of a trait have to be overridden in a wrapper.<br>
<strong>-</strong> StrictLogging gets wrapper class instead of implementation by default. It makes it hard to find the source of log in case where wrapper is used for many implementations.<br>
<strong>-</strong> A wrapper loses implementation type after wrapping making it impossible to call methods specific to the implementation.</p>
<h3 id=tofu-mid-1>Tofu Mid<a hidden class=anchor aria-hidden=true href=#tofu-mid-1>#</a></h3>
<p>Pros:<br>
<strong>+</strong> No need to call an original method directly. Less boilerplate.<br>
<strong>+</strong> Has dsl for initialization that is easy to use.</p>
<p>Cons:<br>
<strong>-</strong> The same problem with StrictLogging as for classic wrapper class. Tofu provides Logging type class but its implementation is too specific.<br>
<strong>-</strong> Mid wrapper also loses original type.<br>
<strong>-</strong> Even though all the methods of a trait have to be overridden, it&rsquo;s much easier with mid. <code>x => x</code> or in other words <code>identity</code> is enough.<br>
<strong>-</strong> One type parameter type has to be introduced to do initialization. It won&rsquo;t work automatically with type <code>KVDao[F[_], K, V]</code> or similar.<br>
<strong>-</strong> The annotation that derives ApplyK has to be added to a class or has to be derived manually.<br>
<strong>-</strong> ApplyK cannot be derived if at least one of the methods returns anything other than F[&mldr;]. So it won&rsquo;t be derived if a trait has a constant method like <code>def groupId: String</code> or a method that returns fs2.Stream.<br>
<strong>-</strong> Mid usage is limited to TF algebras and only to them.</p>
<h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2>
<p>Although usage of Mid reduces boilerplate in wrappers it adds boilerplate in <code>ApplyK</code> derivation and temporary one type parameter introduction cases.<br>
Usage of Mid is very limited and cannot be used as a universal wrapping approach unless you have an ideal Tagless Final application which is a rare thing in reality.</p>
<p>I&rsquo;d recommend using classic wrapper classes as it is a comprehensive, readable, and easy-to-understand solution.</p>
</div>
<footer class=post-footer>
<ul class=post-tags>
<li><a href=https://awethon.github.io/tags/scala/>scala</a></li>
</ul>
</footer>
</article>
</main><footer class=footer>
<span>&copy; 2022 <a href=https://awethon.github.io/>Awethon's Page</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span>
</footer>
<a href=#top aria-label="go to top" title="Go to Top (Alt + G)">
<button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</button>
</a>
<script defer src=/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5+kdJvBz5iKbt6B5PJI=" onload=hljs.initHighlightingOnLoad()></script>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById('menu').scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById('menu').scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(a=>{a.addEventListener("click",function(b){b.preventDefault();var a=this.getAttribute("href").substr(1);window.matchMedia('(prefers-reduced-motion: reduce)').matches?document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(a)}']`).scrollIntoView({behavior:"smooth"}),a==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${a}`)})})</script>
<script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script>
<script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove('dark'),localStorage.setItem("pref-theme",'light')):(document.body.classList.add('dark'),localStorage.setItem("pref-theme",'dark'))})</script>
</body>
</html>