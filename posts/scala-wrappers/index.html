<!doctype html><html lang=en dir=auto><head><meta name=google-site-verification content="qgixNnkm2LoCsgWFtvfJRVqnkpqtr1Xzc5YTPoCL2zc"><meta name=yandex-verification content="c25e903254c44b74"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Different ways to implement wrappers in Scala | Awethon's Page</title>
<meta name=keywords content="scala"><meta name=description content="Scala is a great language with many features and a complex type system.
It provides many ways to solve the same problem, but each way has its own pros and cons.
Unfortunately, it&rsquo;s a common problem of scala developers to utilize the features of Scala, disregarding the cognitive load that it might bring to the team. 
In this article, I&rsquo;ll try to advocate for a simple and easy-to-understand way of implementing wrappers in Scala."><meta name=author content><link rel=canonical href=https://awethon.github.io/posts/scala-wrappers/><link crossorigin=anonymous href=/assets/css/stylesheet.09021785c2d6a3b236e336098504a367e4ee38729622736f68756df5d1990bdb.css integrity="sha256-CQIXhcLWo7I24zYJhQSjZ+TuOHKWInNvaHVt9dGZC9s=" rel="preload stylesheet" as=style><link rel=icon href=https://awethon.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://awethon.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://awethon.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://awethon.github.io/apple-touch-icon.png><link rel=mask-icon href=https://awethon.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://awethon.github.io/posts/scala-wrappers/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Different ways to implement wrappers in Scala"><meta property="og:description" content="Scala is a great language with many features and a complex type system.
It provides many ways to solve the same problem, but each way has its own pros and cons.
Unfortunately, it&rsquo;s a common problem of scala developers to utilize the features of Scala, disregarding the cognitive load that it might bring to the team. 
In this article, I&rsquo;ll try to advocate for a simple and easy-to-understand way of implementing wrappers in Scala."><meta property="og:type" content="article"><meta property="og:url" content="https://awethon.github.io/posts/scala-wrappers/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-20T21:55:20+03:00"><meta property="article:modified_time" content="2024-10-18T23:43:11+03:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Different ways to implement wrappers in Scala"><meta name=twitter:description content="Scala is a great language with many features and a complex type system.
It provides many ways to solve the same problem, but each way has its own pros and cons.
Unfortunately, it&rsquo;s a common problem of scala developers to utilize the features of Scala, disregarding the cognitive load that it might bring to the team. 
In this article, I&rsquo;ll try to advocate for a simple and easy-to-understand way of implementing wrappers in Scala."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://awethon.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Different ways to implement wrappers in Scala","item":"https://awethon.github.io/posts/scala-wrappers/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Different ways to implement wrappers in Scala","name":"Different ways to implement wrappers in Scala","description":"Scala is a great language with many features and a complex type system. It provides many ways to solve the same problem, but each way has its own pros and cons. Unfortunately, it\u0026rsquo;s a common problem of scala developers to utilize the features of Scala, disregarding the cognitive load that it might bring to the team. In this article, I\u0026rsquo;ll try to advocate for a simple and easy-to-understand way of implementing wrappers in Scala.\n","keywords":["scala"],"articleBody":"Scala is a great language with many features and a complex type system. It provides many ways to solve the same problem, but each way has its own pros and cons. Unfortunately, it’s a common problem of scala developers to utilize the features of Scala, disregarding the cognitive load that it might bring to the team. In this article, I’ll try to advocate for a simple and easy-to-understand way of implementing wrappers in Scala.\nBut what are these wrappers and what are they good for? The wrapper pattern (or the proxy pattern) is a design pattern that allows to add new functionality to an existing class without altering it. It is useful in scenarios where an application needs to be instrumented, meaning it needs to be monitored, metered, and traced. Putting all the instrumentation in business logic will make code less readable by mixing business logic with monitoring code. And that’s where wrappers shine. However, they can be used for other purposes as well (like timeouts and retries). (NB: transforming an argument or a return value in a wrapper is considered to be an anti-pattern.)\nThere are two main ways to implement wrappers in Scala: using trait mixins and using classic wrapper classes. In previous edition this article covered a third way of implementing wrappers in Scala using Mid type class from tofu library. But it had many disadvantages and tofu is not maintained anymore. So, I decided to remove it from the article. For some reason trait mixins were widely used in Scala community and in the past using mixins was considered to be “The Scala Way”. And I still see developers using them. However, I don’t think that using mixins is a good idea in most cases. I’ll try to explain why in this article.\nTrait mixin One of the possible ways to create a wrapper is using the trait mixin and abstract override techniques. Scala has a sophisticated mechanism of dynamic class composition (inheritance, technically speaking) that allows to build a class from pieces (traits). While abstract override allows a trait to extend another trait and to provide the implementation of a method in the way that it will be able to call the implementation from its parent.\nMechanism explanation\rI know that the description above might sound like gibberish, so let me explain it with an example. // Our interface trait Printer { def print(): Unit } // A trait that extends Printer and overrides print // in the way that it makes a call to a parent class in its implementation // without any knowledge of what parent it is going to be. // And because there's no parent known, `abstract` keyword is needed. trait PrinterButCooler extends Printer { abstract override def print(): Unit = { printf(\"Hello \") super.print() printf(\"!\") } } // The actual implementation of Printer trait class PrinterImpl() extends Printer { override def print() = printf(\"World\") } new PrinterImpl().print() // Output: World // Now, to add additional functionality to PrinterImpl // we instantiate PrinterImpl and mix it with PrinterButCooler // but at the same time the class PrinterImpl is not aware of PrinterButCooler // as it's only added at the moment of instantiation. (new PrinterImpl() with PrinterButCooler).print() // Output: Hello World! // Using this mechanism, it's possible to compose an implementation with many trait mixins, // but the order of mixins is important as it defines the order of method calls. _ Let’s introduce a simple trait - ItemDao. trait ItemDao { def upsert(item: Item): Unit def get(id: Id): Option[Item] } As an example, we’ll implement mixins for ItemDao logging. To do that we need to create a trait that extends ItemDao and override its methods with abstract modifier (see an explanation in “Mechanism explanation” section). trait LoggedItemDaoWrapper extends ItemDao with StrictLogging { abstract override def upsert(item: Item): Unit = { logger.info(s\"upsert($item) is called\") super.upsert(item) logger.info(s\"upsert($item) = ()\") } abstract override def get(id: Id): Option[Item] = { logger.info(s\"get($id) is called\") val result = super.get(id) logger.info(s\"get($id) = $result\") } } Then, we should initialize a class that implements ItemDao interface and add the wrapper we made into it. new ItemDaoImpl(...) extends LoggedItemDaoWrapper So far it looks clean and seems easy to understand. You might be even eager to try it in your project, but unfortunately, it’s not that simple. Code is going to become messy if there are dependencies to provide. To show that, let’s make our trait return Future values: trait ItemDao { def upsert(item: Item): Future[Unit] def get(id: Id): Future[Option[Item]] } If a trait has methods that return Future, then an ExecutionContext must be provided. Otherwise, we won’t be able to call map, flatMap, and other methods of Future in the logic of our wrappers.\nThe most common workaround for this I have seen is to create a global single thread execution context. But what if it’s not an option? Then we have to provide ExecutionContext through the override def mechanism.\ntrait LoggedItemDaoWrapper extends ItemDao with StrictLogging { protected implicit def ec: ExecutionContext abstract override def upsert(item: Item): Future[Unit] = { super.upsert(item).map(_ =\u003e logger.info(s\"upsert($item) = ()\")) } abstract override def get(id: Id): Future[Option[Item]] = { super.get(id).map(result =\u003e logger.info(s\"get($id) = $result\")) } } val itemDao: ItemDao = new ItemDaoImpl(...) extends LoggedItemDaoWrapper { override def ec = yourEc } The code of initialization is not as clear as before because ExecutionContext has to be provided through the override def mechanism. An initialization order has to be kept in mind as it’s possible to get NullPointerException.\nThe more dependencies are stacked together the worse it gets.\nIt becomes even worse with Tagless Final. When we write our wrappers with TF in a project, we can’t do much with F[_] unless we have instances of typeclasses in a scope together with it. It would be reasonable to assume that each wrapper works with different set of type classes. So, when it comes to initialization, we’re doomed because now we need to provide all the dependencies for each wrapper.\nHere’s an example of what TF code might look like: trait ItemDao[F[_]] { def upsert(item: Item): F[Unit] def get(id: Id): F[Option[Item]] } trait LoggedItemDaoWrapper[F[_]] extends ItemDao[F] with StrictLogging { implicit protected def mt: MonadThrow[F] abstract override def upsert(item: Item): F[Unit] = { super.upsert(item).attemptTap(...) } abstract override def get(id: Id): F[Option[Item]] = { super.get(id).attemptTap(...) } } val itemDao: ItemDao[F] = new ItemDaoImpl[F](...) extends LoggedItemDaoWrapper[F] with MeteredItemDaoWrapper[F] with TimeoutItemDaoWrapper[F] { override def mt: MonadThrow[F] = async override def at: ApplicativeError[F] = async override def concurrent: Concurrent[F] = async override def timer: Timer[F] = _timer override def gauge: Gauge = methodCallGauge } Does it look ugly to you? It does to me. However, I would lie if I said there’s nothing we can do about it. The workaround we can apply to reduce the amount of boilerplate, is to create provider traits that will provide all the necessary dependencies for wrappers.\ntrait MonadThrowProvider[F[_]] extends ApplicativeThrowProvider[F] { implicit protected def mt: MonadThrow[F] override implicit protected def at: ApplicativeError[F] = mt } trait LoggingProvider[F[_]] extends MonadThrowProvider[F] with StrictLogging trait LoggedItemDaoWrapper[F[_]] extends ItemDao[F] with LoggingProvider[F] { abstract override def upsert(item: Item): F[Unit] = { super.upsert(item).attemptTap(...) } abstract override def get(id: Id): F[Option[Item]] = { super.get(id).attemptTap(...) } } As we’re already in this rabbit hole of blasphemy, we can go even further. Composing all providers into an all-in-one provider might be a good idea to reduce boilerplate in the initialization code. trait AllInOneProvider[F[_]] extends MonadThrowProvider[F] with ConcurrentProvider[F] with TimerProvider[F] with ClockProvider[F] with PrometheusGaugeProvider { override def mt: MonadThrow[F] = async override def concurrent: Concurrent[F] = async override def timer: Timer[F] = _timer override def clock: Clock[F] = _clock override def gauge: Gauge = methodCallGauge } // now with all-in-one provider the initialization code is quite clean val itemDao: ItemDao[F] = new ItemDaoImpl[F](...) extends LoggedItemDaoWrapper[F] with MeteredItemDaoWrapper[F] with TimeoutItemDaoWrapper[F] with AllInOneProvider[F] Finally, we have managed to hide all the ugly stuff behind AllInOneProvider trait and provider traits, but it’s hard to track the provided dependencies and their initialization.\nYes, it looks clean, but the code now smells even more. As this dependency provision is very exotic and completely unmaintainable. Not only that but such encoding of dependencies is very unnatural for Tagless Final and functional programming in general.\nClassic wrapper class Who would have thought that the classic way of doing things is the best way? The way that was designed for OOP languages works incredibly well in Scala with both Tagless Final and Scala Future. But I’m getting ahead of myself. Let’s introduce the same logging wrapper but using a classic wrapper class. And let’s do it for plain values, then for Future and finally for F[_].\nclass LoggedItemDaoWrapper(itemDao: ItemDao) extends ItemDao with StrictLogging { override def upsert(item: Item): Unit = { logger.info(s\"upsert($item) is called\") itemDao.upsert(item) logger.info(s\"upsert($item) = ()\") } override def get(id: Id): Option[Item] = { logger.info(s\"get($id) is called\") val result = itemDao.get(id) logger.info(s\"get($id) = $result\") } } class LoggedItemDaoWrapper(itemDao: ItemDao)(implicit ec: ExecutionContext) extends ItemDao with StrictLogging { override def upsert(item: Item): Future[Unit] = { itemDao.upsert(item).map(_ =\u003e logger.info(s\"upsert($item) = ()\")) } override def get(id: Id): Future[Option[Item]] = { super.get(id).map(result =\u003e logger.info(s\"get($id) = $result\")) } } class LoggedItemDaoWrapper[F[_]: MonadThrow](itemDao: ItemDao[F]) extends ItemDao[F] with StrictLogging { override def upsert(item: Item): F[Unit] = { itemDao.upsert(item).attemptTap(...) } override def get(id: Id): F[Option[Item]] = { itemDao.get(id).attemptTap(...) } } Looks nice! Easy to read and everything looks as idiomatic as it gets. But what about initialization?\nWell, having constructor parameters and implicit parameters reduces boilerplate significantly. With composition instead of inheritance we can easily wrap our implementation with as many wrappers as we want. It’s now clear which dependencies are used and to where they are passed.\nval itemDao: ItemDao[F] = new TimeoutItemDaoWrapper[F](timeoutsConfig)( new MeteredItemDaoWrapper[F](gauge)( new LoggedItemDaoWrapper[F]( new ItemDaoImpl[F](...) ) ) ) Syntactic sugar for class wrappers OOP wrappers make code look nice and tidy, but there are a few minor inconveniences. We wrap our implementation with wrappers and wrapper names now appear from the outermost wrapper to the innermost one. The other inconvinience is that we get nested code with probably the beefiest initialization code (ItemDaoImpl) in the innermost part.\nWith the power of Scala implicits, it is pretty easy to solve these issues.\nimplicit class WrapperHelper[A](private val a: A) extends AnyVal { def `with`[B \u003e: A](wrap: A =\u003e B): B = wrap(a) } \\\nTo achieve the best readability, we should add a companion object with apply function to our wrappers and have dependencies listed before to-be-wrapped class. On top of that we should separate dependencies and an implementation class with curring. Like this: class Wrapper[F[_]: TC1: TC2](dep1: Dep1, dep2: Dep2[F], o: MyClass[F]) extends MyClass[F] { ... } object Wrapper { def apply[F[_]: TC1: TC2](dep1: Dep1, dep2: Dep2[F])(o: MyClass[F]) = new Wrapper(dep1, dep2, o) } So the initialization code will look like this: myClassImpl .`with`(Wrapper1(dep1, dep2)) .`with`(Wrapper2(dep3))\nGame-changing distinction between inheritance-based wrapping (trait mixins) and composition-based wrapping (classic wrapper class) This distinction can be both very useful and very harmful, depending on the use case. The fact of the matter is that inheritance-based wrapping is able to call wrapped methods inside the implementation, while composition-based wrapping is not able to do so. So if you have an implementation that calls its own public methods inside, then with inheritance-based wrapping these internal calls will be wrapped as well.\nBelow, I wrote an example that will highlight described distinction.\nCode example\rtrait Printer { def print(): Unit def threeTimesPrint(): Unit } trait LoggedPrinter extends Printer { abstract override def print(): Unit = { println(\"Print method is called\") super.print() } abstract override def threeTimesPrint(): Unit = { println(\"ThreeTimesPrint method is called\") super.threeTimesPrint() } } class LoggedPrinter2(printer: Printer) extends Printer { override def print(): Unit = { println(\"Print method is called\") printer.print() } override def threeTimesPrint(): Unit = { println(\"ThreeTimesPrint method is called\") printer.threeTimesPrint() } } class PrinterImpl() extends Printer { override def print() = println(\"A\") override def threeTimesPrint() = 1.to(3).foreach(_ =\u003e print()) } // Output: // ThreeTimesPrint method is called // Print method is called // A // Print method is called // A // Print method is called // A (new PrinterImpl() with LoggedPrinter).threeTimesPrint() // Output: // ThreeTimesPrint method is called // A // A // A (new LoggedPrinter2(new PrinterImpl())).threeTimesPrint() Pros and Cons At the end of the article, it might seem that choice is clear, however after digging into details, many limitations and downsides are found.\nTrait mixin Pros:\n+ Preserves implementation type after wrapping. new ItemDaoImpl(...) extends LoggedItemDao has type ItemDaoImpl with LoggedItemDao. So it is possible to use any methods from ItemDaoImpl.\n+ With mixin traits it’s possible omit the methods that don’t need modification of their behavior. If we have a trait with 10 methods but want to add logging to one of them, then only one abstract override of the method needs to be written in a mixin.\n+ Wrapped version of a method is invoked on an inner call.\nCons:\n- Providing dependencies creates a lot of boilerplate.\n- Wrapping uses an inheritance mechanism. The order of initialization may not be clear.\n- Might lead to NPEs during initialization.\n- Looks ugly with Tagless Final.\n- Scala compiler doesn’t provide any warnings or errors if a method is not overridden in a wrapper.\n- Wrapped version of a method is invoked on an inner call. (Might be a downside in some cases)\nClassic wrapper class Pros:\n+ Easy-to-understand GOF pattern from OOP languages.\n+ Doesn’t get complicated no matter how many wrappers are composed.\n+ It’s possible to simplify initialization even more with syntactic sugar.\n+ Easy to use with Tagless Final.\n+ Scala compiler provides errors if a method is not overridden in a wrapper.\n+ When public method is called in an implementation internally, then none of the wrappers will be used.\nCons:\n- All the methods of a trait have to be overridden in a wrapper.\n- StrictLogging gets wrapper class instead of implementation by default.\n- A wrapper loses implementation type after wrapping making it impossible to call methods specific to the implementation.\n- When public method is called in an implementation internally, then none of the wrappers will be used.\nConclusion In my experience, the classic wrapper classes are the way to go. They are easy to understand, easy to use, and easy to maintain. I’m yet to see a case where it’s not the best choice.\n","wordCount":"2379","inLanguage":"en","datePublished":"2022-02-20T21:55:20+03:00","dateModified":"2024-10-18T23:43:11+03:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://awethon.github.io/posts/scala-wrappers/"},"publisher":{"@type":"Organization","name":"Awethon's Page","logo":{"@type":"ImageObject","url":"https://awethon.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://awethon.github.io/ accesskey=h title="Awethon's Page (Alt + H)">Awethon's Page</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://awethon.github.io/posts/ title=Posts><span>Posts</span></a></li><li><a href=https://awethon.github.io/tags/ title=Tags><span>Tags</span></a></li><li><a href=https://awethon.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">Different ways to implement wrappers in Scala</h1><div class=post-meta><span title='2022-02-20 21:55:20 +0300 +0300'>February 20, 2022</span>&nbsp;|&nbsp;<a href=https://github.com/Awethon/awethon.github.io/blob/master/content/posts/scala-wrappers.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><p>Scala is a great language with many features and a complex type system.
It provides many ways to solve the same problem, but each way has its own pros and cons.
Unfortunately, it&rsquo;s a common problem of scala developers to utilize the features of Scala, disregarding the cognitive load that it might bring to the team.<br>In this article, I&rsquo;ll try to advocate for a simple and easy-to-understand way of implementing wrappers in Scala.</p><p>But what are these wrappers and what are they good for?<br>The wrapper pattern (or the proxy pattern) is a design pattern that allows to add new functionality to an existing class without altering it.
It is useful in scenarios where an application needs to be instrumented, meaning it needs to be monitored, metered, and traced.
Putting all the instrumentation in business logic will make code less readable by mixing business logic with monitoring code.
And that&rsquo;s where wrappers shine. However, they can be used for other purposes as well (like timeouts and retries).<br>(NB: transforming an argument or a return value in a wrapper is considered to be an anti-pattern.)</p><p>There are two main ways to implement wrappers in Scala: using trait mixins and using classic wrapper classes.
In previous edition this article covered a third way of implementing wrappers in Scala using <code>Mid</code> type class from <code>tofu</code> library. But it had many disadvantages and <code>tofu</code> is not maintained anymore. So, I decided to remove it from the article.
For some reason trait mixins were widely used in Scala community and in the past using mixins was considered to be &ldquo;The Scala Way&rdquo;. And I still see developers using them.
However, I don&rsquo;t think that using mixins is a good idea in most cases. I&rsquo;ll try to explain why in this article.</p><h2 id=trait-mixin>Trait mixin<a hidden class=anchor aria-hidden=true href=#trait-mixin>#</a></h2><p>One of the possible ways to create a wrapper is using the trait mixin and abstract override techniques.
Scala has a sophisticated mechanism of dynamic class composition (inheritance, technically speaking) that allows to build a class from pieces (traits).
While abstract override allows a trait to extend another trait and to provide the implementation of a method in the way that it will be able to call the implementation from its parent.</p><style type=text/css>.unselectable{-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}</style><details><summary class=unselectable><u>Mechanism explanation</u></summary><div style=padding-top:8px></div>I know that the description above might sound like gibberish, so let me explain it with an example.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#75715e>// Our interface
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>Printer</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> print<span style=color:#f92672>()</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Unit</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// A trait that extends Printer and overrides print
</span></span></span><span style=display:flex><span><span style=color:#75715e>// in the way that it makes a call to a parent class in its implementation
</span></span></span><span style=display:flex><span><span style=color:#75715e>// without any knowledge of what parent it is going to be.
</span></span></span><span style=display:flex><span><span style=color:#75715e>// And because there&#39;s no parent known, `abstract` keyword is needed.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>PrinterButCooler</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Printer</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> print<span style=color:#f92672>()</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Unit</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    printf<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Hello &#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span>print<span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>    printf<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;!&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// The actual implementation of Printer trait
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PrinterImpl</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Printer</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> print<span style=color:#f92672>()</span> <span style=color:#66d9ef>=</span> printf<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;World&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>new</span> <span style=color:#a6e22e>PrinterImpl</span><span style=color:#f92672>().</span>print<span style=color:#f92672>()</span> <span style=color:#75715e>// Output: World
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Now, to add additional functionality to PrinterImpl
</span></span></span><span style=display:flex><span><span style=color:#75715e>// we instantiate PrinterImpl and mix it with PrinterButCooler
</span></span></span><span style=display:flex><span><span style=color:#75715e>// but at the same time the class PrinterImpl is not aware of PrinterButCooler
</span></span></span><span style=display:flex><span><span style=color:#75715e>// as it&#39;s only added at the moment of instantiation.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> <span style=color:#a6e22e>PrinterImpl</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>PrinterButCooler</span><span style=color:#f92672>).</span>print<span style=color:#f92672>()</span> <span style=color:#75715e>// Output: Hello World!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Using this mechanism, it&#39;s possible to compose an implementation with many trait mixins,
</span></span></span><span style=display:flex><span><span style=color:#75715e>// but the order of mixins is important as it defines the order of method calls.
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>_</span></span></span></code></pre></div></details></br><p>Let&rsquo;s introduce a simple trait - ItemDao.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>ItemDao</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Unit</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span></span></span></code></pre></div><br>As an example, we&rsquo;ll implement mixins for ItemDao logging. To do that we need to create a trait that extends ItemDao and override its methods with abstract modifier (see an explanation in &ldquo;Mechanism explanation&rdquo; section).<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>ItemDao</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>StrictLogging</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Unit</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;upsert(</span><span style=color:#e6db74>$item</span><span style=color:#e6db74>) is called&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span>upsert<span style=color:#f92672>(</span>item<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;upsert(</span><span style=color:#e6db74>$item</span><span style=color:#e6db74>) = ()&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;get(</span><span style=color:#e6db74>$id</span><span style=color:#e6db74>) is called&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> result <span style=color:#66d9ef>=</span> <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span>get<span style=color:#f92672>(</span>id<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;get(</span><span style=color:#e6db74>$id</span><span style=color:#e6db74>) = </span><span style=color:#e6db74>$result</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span></span></span></code></pre></div><br>Then, we should initialize a class that implements ItemDao interface and add the wrapper we made into it.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ItemDaoImpl</span><span style=color:#f92672>(...)</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span></span></span></code></pre></div><br>So far it looks clean and seems easy to understand.
You might be even eager to try it in your project, but unfortunately, it&rsquo;s not that simple.
Code is going to become messy if there are dependencies to provide.<br>To show that, let&rsquo;s make our trait return <code>Future</code> values:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>ItemDao</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Future</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Unit</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Future</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span></span></span></code></pre></div><br>If a trait has methods that return <code>Future</code>, then an <code>ExecutionContext</code> must be provided. Otherwise, we won&rsquo;t be able to call <code>map</code>, <code>flatMap</code>, and other methods of <code>Future</code> in the logic of our wrappers.<br>The most common workaround for this I have seen is to create a global single thread execution context. But what if it&rsquo;s not an option? Then we have to provide <code>ExecutionContext</code> through the <code>override def</code> mechanism.</p><p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>ItemDao</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>StrictLogging</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>def</span> ec<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ExecutionContext</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Future</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Unit</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span>upsert<span style=color:#f92672>(</span>item<span style=color:#f92672>).</span>map<span style=color:#f92672>(</span><span style=color:#66d9ef>_</span> <span style=color:#66d9ef>=&gt;</span> logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;upsert(</span><span style=color:#e6db74>$item</span><span style=color:#e6db74>) = ()&#34;</span><span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Future</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span>get<span style=color:#f92672>(</span>id<span style=color:#f92672>).</span>map<span style=color:#f92672>(</span>result <span style=color:#66d9ef>=&gt;</span> logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;get(</span><span style=color:#e6db74>$id</span><span style=color:#e6db74>) = </span><span style=color:#e6db74>$result</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> itemDao<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ItemDao</span> <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ItemDaoImpl</span><span style=color:#f92672>(...)</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> ec <span style=color:#66d9ef>=</span> yourEc
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span></span></span></code></pre></div><br>The code of initialization is not as clear as before because <code>ExecutionContext</code> has to be provided through the <code>override def</code> mechanism.
An initialization order has to be kept in mind as it&rsquo;s possible to get <code>NullPointerException</code>.<br>The more dependencies are stacked together the worse it gets.</p><p>It becomes even worse with Tagless Final.<br>When we write our wrappers with TF in a project, we can&rsquo;t do much with <code>F[_]</code> unless we have instances of typeclasses in a scope together with it.
It would be reasonable to assume that each wrapper works with different set of type classes.
So, when it comes to initialization, we&rsquo;re doomed because now we need to provide all the dependencies for each wrapper.</p><p>Here&rsquo;s an example of what TF code might look like:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>ItemDao</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>_</span><span style=color:#f92672>]]</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Unit</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]]</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>_</span><span style=color:#f92672>]]</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>ItemDao</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>StrictLogging</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>def</span> mt<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>MonadThrow</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Unit</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span>upsert<span style=color:#f92672>(</span>item<span style=color:#f92672>).</span>attemptTap<span style=color:#f92672>(...)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span>get<span style=color:#f92672>(</span>id<span style=color:#f92672>).</span>attemptTap<span style=color:#f92672>(...)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>val</span> itemDao<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ItemDao</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ItemDaoImpl</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>](...)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>MeteredItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>TimeoutItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> mt<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>MonadThrow</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> async
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> at<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ApplicativeError</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> async
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> concurrent<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Concurrent</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> async
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> timer<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Timer</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>_timer</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> gauge<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Gauge</span> <span style=color:#f92672>=</span> methodCallGauge
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span> </span></span></code></pre></div><br>Does it look ugly to you? It does to me. However, I would lie if I said there&rsquo;s nothing we can do about it.<br>The workaround we can apply to reduce the amount of boilerplate, is to create provider traits that will provide all the necessary dependencies for wrappers.</p><p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>MonadThrowProvider</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>_</span><span style=color:#f92672>]]</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>ApplicativeThrowProvider</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>def</span> mt<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>MonadThrow</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>protected</span> <span style=color:#66d9ef>def</span> at<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ApplicativeError</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> mt
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>LoggingProvider</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>_</span><span style=color:#f92672>]]</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>MonadThrowProvider</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>StrictLogging</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>_</span><span style=color:#f92672>]]</span> <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>ItemDao</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>LoggingProvider</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Unit</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span>upsert<span style=color:#f92672>(</span>item<span style=color:#f92672>).</span>attemptTap<span style=color:#f92672>(...)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span>get<span style=color:#f92672>(</span>id<span style=color:#f92672>).</span>attemptTap<span style=color:#f92672>(...)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span></span></span></code></pre></div><br>As we&rsquo;re already in this rabbit hole of blasphemy, we can go even further.
Composing all providers into an all-in-one provider might be a good idea to reduce boilerplate in the initialization code.<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>AllInOneProvider</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>_</span><span style=color:#f92672>]]</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>extends</span> <span style=color:#a6e22e>MonadThrowProvider</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>ConcurrentProvider</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>TimerProvider</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>ClockProvider</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>PrometheusGaugeProvider</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> mt<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>MonadThrow</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> async
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> concurrent<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Concurrent</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> async
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> timer<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Timer</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>_timer</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> clock<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Clock</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>_clock</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> gauge<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Gauge</span> <span style=color:#f92672>=</span> methodCallGauge
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// now with all-in-one provider the initialization code is quite clean
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>val</span> itemDao<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ItemDao</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ItemDaoImpl</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>](...)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>MeteredItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>TimeoutItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>AllInOneProvider</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span></span></span></code></pre></div><br>Finally, we have managed to hide all the ugly stuff behind AllInOneProvider trait and provider traits, but it&rsquo;s hard to track the provided dependencies and their initialization.<br>Yes, it looks clean, but the code now smells even more. As this dependency provision is very exotic and completely unmaintainable.
Not only that but such encoding of dependencies is very unnatural for Tagless Final and functional programming in general.</p><h2 id=classic-wrapper-class>Classic wrapper class<a hidden class=anchor aria-hidden=true href=#classic-wrapper-class>#</a></h2><p>Who would have thought that the classic way of doing things is the best way?
The way that was designed for OOP languages works incredibly well in Scala with both Tagless Final and Scala Future.
But I&rsquo;m getting ahead of myself. Let&rsquo;s introduce the same logging wrapper but using a classic wrapper class.
And let&rsquo;s do it for plain values, then for <code>Future</code> and finally for <code>F[_]</code>.</p><p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span><span style=color:#f92672>(</span>itemDao<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ItemDao</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>ItemDao</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>StrictLogging</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Unit</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;upsert(</span><span style=color:#e6db74>$item</span><span style=color:#e6db74>) is called&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    itemDao<span style=color:#f92672>.</span>upsert<span style=color:#f92672>(</span>item<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;upsert(</span><span style=color:#e6db74>$item</span><span style=color:#e6db74>) = ()&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;get(</span><span style=color:#e6db74>$id</span><span style=color:#e6db74>) is called&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> result <span style=color:#66d9ef>=</span> itemDao<span style=color:#f92672>.</span>get<span style=color:#f92672>(</span>id<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;get(</span><span style=color:#e6db74>$id</span><span style=color:#e6db74>) = </span><span style=color:#e6db74>$result</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span><span style=color:#f92672>(</span>itemDao<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ItemDao</span><span style=color:#f92672>)(</span><span style=color:#66d9ef>implicit</span> ec<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ExecutionContext</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>ItemDao</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>StrictLogging</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Future</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Unit</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    itemDao<span style=color:#f92672>.</span>upsert<span style=color:#f92672>(</span>item<span style=color:#f92672>).</span>map<span style=color:#f92672>(</span><span style=color:#66d9ef>_</span> <span style=color:#66d9ef>=&gt;</span> logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;upsert(</span><span style=color:#e6db74>$item</span><span style=color:#e6db74>) = ()&#34;</span><span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Future</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span>get<span style=color:#f92672>(</span>id<span style=color:#f92672>).</span>map<span style=color:#f92672>(</span>result <span style=color:#66d9ef>=&gt;</span> logger<span style=color:#f92672>.</span>info<span style=color:#f92672>(</span><span style=color:#e6db74>s&#34;get(</span><span style=color:#e6db74>$id</span><span style=color:#e6db74>) = </span><span style=color:#e6db74>$result</span><span style=color:#e6db74>&#34;</span><span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>_</span><span style=color:#f92672>]</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>MonadThrow</span><span style=color:#f92672>](</span>itemDao<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ItemDao</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>])</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>ItemDao</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>StrictLogging</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> upsert<span style=color:#f92672>(</span>item<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Item</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Unit</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    itemDao<span style=color:#f92672>.</span>upsert<span style=color:#f92672>(</span>item<span style=color:#f92672>).</span>attemptTap<span style=color:#f92672>(...)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> get<span style=color:#f92672>(</span>id<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Id</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Option</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Item</span><span style=color:#f92672>]]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    itemDao<span style=color:#f92672>.</span>get<span style=color:#f92672>(</span>id<span style=color:#f92672>).</span>attemptTap<span style=color:#f92672>(...)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span></span></span></code></pre></div><br>Looks nice! Easy to read and everything looks as idiomatic as it gets. But what about initialization?<br>Well, having constructor parameters and implicit parameters reduces boilerplate significantly.
With composition instead of inheritance we can easily wrap our implementation with as many wrappers as we want.
It&rsquo;s now clear which dependencies are used and to where they are passed.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#66d9ef>val</span> itemDao<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ItemDao</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>TimeoutItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>](</span>timeoutsConfig<span style=color:#f92672>)(</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>MeteredItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>](</span>gauge<span style=color:#f92672>)(</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>LoggedItemDaoWrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>](</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>ItemDaoImpl</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>](...)</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>)</span></span></span></code></pre></div><h3 id=syntactic-sugar-for-class-wrappers>Syntactic sugar for class wrappers<a hidden class=anchor aria-hidden=true href=#syntactic-sugar-for-class-wrappers>#</a></h3><p>OOP wrappers make code look nice and tidy, but there are a few minor inconveniences.
We wrap our implementation with wrappers and wrapper names now appear from the outermost wrapper to the innermost one.
The other inconvinience is that we get nested code with probably the beefiest initialization code (<code>ItemDaoImpl</code>) in the innermost part.</p><p>With the power of Scala implicits, it is pretty easy to solve these issues.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WrapperHelper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>A</span><span style=color:#f92672>](</span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>val</span> a<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>A</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>AnyVal</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> `with`<span style=color:#f92672>[</span><span style=color:#66d9ef>B</span> <span style=color:#66d9ef>&gt;:</span> <span style=color:#66d9ef>A</span><span style=color:#f92672>](</span>wrap<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>A</span> <span style=color:#f92672>=&gt;</span> B<span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>B</span> <span style=color:#f92672>=</span> wrap<span style=color:#f92672>(</span>a<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span></span></span></code></pre></div><p>\</p><p>To achieve the best readability, we should add a companion object with <code>apply</code> function to our wrappers and have dependencies listed before to-be-wrapped class.
On top of that we should separate dependencies and an implementation class with curring.
Like this:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span>  <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Wrapper</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>_</span><span style=color:#f92672>]</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>TC1:</span> <span style=color:#66d9ef>TC2</span><span style=color:#f92672>](</span>dep1<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Dep1</span><span style=color:#f92672>,</span> dep2<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Dep2</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>],</span> o<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>MyClass</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>])</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>MyClass</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>]</span> <span style=color:#f92672>{</span> <span style=color:#f92672>...</span> <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>object</span> <span style=color:#a6e22e>Wrapper</span> <span style=color:#f92672>{</span> <span style=color:#66d9ef>def</span> apply<span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>[</span><span style=color:#66d9ef>_</span><span style=color:#f92672>]</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>TC1:</span> <span style=color:#66d9ef>TC2</span><span style=color:#f92672>](</span>dep1<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Dep1</span><span style=color:#f92672>,</span> dep2<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Dep2</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>])(</span>o<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>MyClass</span><span style=color:#f92672>[</span><span style=color:#66d9ef>F</span><span style=color:#f92672>])</span> <span style=color:#66d9ef>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Wrapper</span><span style=color:#f92672>(</span>dep1<span style=color:#f92672>,</span> dep2<span style=color:#f92672>,</span> o<span style=color:#f92672>)</span> <span style=color:#f92672>}</span></span></span></code></pre></div><br>So the initialization code will look like this:<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span>myClassImpl
</span></span><span style=display:flex><span>  <span style=color:#f92672>.</span>`with`<span style=color:#f92672>(</span><span style=color:#a6e22e>Wrapper1</span><span style=color:#f92672>(</span>dep1<span style=color:#f92672>,</span> dep2<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>.</span>`with`<span style=color:#f92672>(</span><span style=color:#a6e22e>Wrapper2</span><span style=color:#f92672>(</span>dep3<span style=color:#f92672>))</span></span></span></code></pre></div></p><h2 id=game-changing-distinction-between-inheritance-based-wrapping-trait-mixins-and-composition-based-wrapping-classic-wrapper-class>Game-changing distinction between inheritance-based wrapping (trait mixins) and composition-based wrapping (classic wrapper class)<a hidden class=anchor aria-hidden=true href=#game-changing-distinction-between-inheritance-based-wrapping-trait-mixins-and-composition-based-wrapping-classic-wrapper-class>#</a></h2><p>This distinction can be both very useful and very harmful, depending on the use case.
The fact of the matter is that inheritance-based wrapping is able to call wrapped methods inside the implementation, while composition-based wrapping is not able to do so.
So if you have an implementation that calls its own public methods inside, then with inheritance-based wrapping these internal calls will be wrapped as well.</p><p>Below, I wrote an example that will highlight described distinction.</p><style type=text/css>.unselectable{-webkit-touch-callout:none;-webkit-user-select:none;-khtml-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}</style><details><summary class=unselectable><u>Code example</u></summary><div style=padding-top:8px></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>Printer</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> print<span style=color:#f92672>()</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Unit</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>def</span> threeTimesPrint<span style=color:#f92672>()</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Unit</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>trait</span> <span style=color:#a6e22e>LoggedPrinter</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Printer</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> print<span style=color:#f92672>()</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Unit</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    println<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Print method is called&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span>print<span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>abstract</span> <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> threeTimesPrint<span style=color:#f92672>()</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Unit</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    println<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;ThreeTimesPrint method is called&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>super</span><span style=color:#f92672>.</span>threeTimesPrint<span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>LoggedPrinter2</span><span style=color:#f92672>(</span>printer<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Printer</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Printer</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> print<span style=color:#f92672>()</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Unit</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    println<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;Print method is called&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    printer<span style=color:#f92672>.</span>print<span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> threeTimesPrint<span style=color:#f92672>()</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Unit</span> <span style=color:#f92672>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    println<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;ThreeTimesPrint method is called&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    printer<span style=color:#f92672>.</span>threeTimesPrint<span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>PrinterImpl</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>Printer</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> print<span style=color:#f92672>()</span> <span style=color:#66d9ef>=</span> println<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;A&#34;</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>override</span> <span style=color:#66d9ef>def</span> threeTimesPrint<span style=color:#f92672>()</span> <span style=color:#66d9ef>=</span> <span style=color:#ae81ff>1.</span>to<span style=color:#f92672>(</span><span style=color:#ae81ff>3</span><span style=color:#f92672>).</span>foreach<span style=color:#f92672>(</span><span style=color:#66d9ef>_</span> <span style=color:#66d9ef>=&gt;</span> print<span style=color:#f92672>())</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Output:
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ThreeTimesPrint method is called
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Print method is called
</span></span></span><span style=display:flex><span><span style=color:#75715e>// A
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Print method is called
</span></span></span><span style=display:flex><span><span style=color:#75715e>// A
</span></span></span><span style=display:flex><span><span style=color:#75715e>// Print method is called
</span></span></span><span style=display:flex><span><span style=color:#75715e>// A
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> <span style=color:#a6e22e>PrinterImpl</span><span style=color:#f92672>()</span> <span style=color:#66d9ef>with</span> <span style=color:#a6e22e>LoggedPrinter</span><span style=color:#f92672>).</span>threeTimesPrint<span style=color:#f92672>()</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Output:
</span></span></span><span style=display:flex><span><span style=color:#75715e>// ThreeTimesPrint method is called
</span></span></span><span style=display:flex><span><span style=color:#75715e>// A
</span></span></span><span style=display:flex><span><span style=color:#75715e>// A
</span></span></span><span style=display:flex><span><span style=color:#75715e>// A
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> <span style=color:#a6e22e>LoggedPrinter2</span><span style=color:#f92672>(</span><span style=color:#66d9ef>new</span> <span style=color:#a6e22e>PrinterImpl</span><span style=color:#f92672>())).</span>threeTimesPrint<span style=color:#f92672>()</span></span></span></code></pre></div></details></br><h2 id=pros-and-cons>Pros and Cons<a hidden class=anchor aria-hidden=true href=#pros-and-cons>#</a></h2><p>At the end of the article, it might seem that choice is clear, however after digging into details, many limitations and downsides are found.</p><h3 id=trait-mixin-1>Trait mixin<a hidden class=anchor aria-hidden=true href=#trait-mixin-1>#</a></h3><p>Pros:<br><strong>+</strong> Preserves implementation type after wrapping. <code>new ItemDaoImpl(...) extends LoggedItemDao</code> has type <code>ItemDaoImpl with LoggedItemDao</code>. So it is possible to use any methods from <code>ItemDaoImpl</code>.<br><strong>+</strong> With mixin traits it&rsquo;s possible omit the methods that don&rsquo;t need modification of their behavior. If we have a trait with 10 methods but want to add logging to one of them, then only one abstract override of the method needs to be written in a mixin.<br><strong>+</strong> Wrapped version of a method is invoked on an inner call.</p><p>Cons:<br><strong>-</strong> Providing dependencies creates a lot of boilerplate.<br><strong>-</strong> Wrapping uses an inheritance mechanism. The order of initialization may not be clear.<br><strong>-</strong> Might lead to NPEs during initialization.<br><strong>-</strong> Looks ugly with Tagless Final.<br><strong>-</strong> Scala compiler doesn&rsquo;t provide any warnings or errors if a method is not overridden in a wrapper.<br><strong>-</strong> Wrapped version of a method is invoked on an inner call. (Might be a downside in some cases)</p><h3 id=classic-wrapper-class-1>Classic wrapper class<a hidden class=anchor aria-hidden=true href=#classic-wrapper-class-1>#</a></h3><p>Pros:<br><strong>+</strong> Easy-to-understand GOF pattern from OOP languages.<br><strong>+</strong> Doesn&rsquo;t get complicated no matter how many wrappers are composed.<br><strong>+</strong> It&rsquo;s possible to simplify initialization even more with syntactic sugar.<br><strong>+</strong> Easy to use with Tagless Final.<br><strong>+</strong> Scala compiler provides errors if a method is not overridden in a wrapper.<br><strong>+</strong> When public method is called in an implementation internally, then none of the wrappers will be used.</p><p>Cons:<br><strong>-</strong> All the methods of a trait have to be overridden in a wrapper.<br><strong>-</strong> StrictLogging gets wrapper class instead of implementation by default.<br><strong>-</strong> A wrapper loses implementation type after wrapping making it impossible to call methods specific to the implementation.<br><strong>-</strong> When public method is called in an implementation internally, then none of the wrappers will be used.</p><h2 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h2><p>In my experience, the classic wrapper classes are the way to go.
They are easy to understand, easy to use, and easy to maintain.
I&rsquo;m yet to see a case where it&rsquo;s not the best choice.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://awethon.github.io/tags/scala/>Scala</a></li></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Different ways to implement wrappers in Scala on x" href="https://x.com/intent/tweet/?text=Different%20ways%20to%20implement%20wrappers%20in%20Scala&amp;url=https%3a%2f%2fawethon.github.io%2fposts%2fscala-wrappers%2f&amp;hashtags=scala"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Different ways to implement wrappers in Scala on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fawethon.github.io%2fposts%2fscala-wrappers%2f&amp;title=Different%20ways%20to%20implement%20wrappers%20in%20Scala&amp;summary=Different%20ways%20to%20implement%20wrappers%20in%20Scala&amp;source=https%3a%2f%2fawethon.github.io%2fposts%2fscala-wrappers%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Different ways to implement wrappers in Scala on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fawethon.github.io%2fposts%2fscala-wrappers%2f&title=Different%20ways%20to%20implement%20wrappers%20in%20Scala"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Different ways to implement wrappers in Scala on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fawethon.github.io%2fposts%2fscala-wrappers%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Different ways to implement wrappers in Scala on whatsapp" href="https://api.whatsapp.com/send?text=Different%20ways%20to%20implement%20wrappers%20in%20Scala%20-%20https%3a%2f%2fawethon.github.io%2fposts%2fscala-wrappers%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Different ways to implement wrappers in Scala on telegram" href="https://telegram.me/share/url?text=Different%20ways%20to%20implement%20wrappers%20in%20Scala&amp;url=https%3a%2f%2fawethon.github.io%2fposts%2fscala-wrappers%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Different ways to implement wrappers in Scala on ycombinator" href="https://news.ycombinator.com/submitlink?t=Different%20ways%20to%20implement%20wrappers%20in%20Scala&u=https%3a%2f%2fawethon.github.io%2fposts%2fscala-wrappers%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=https://awethon.github.io/>Awethon's Page</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>